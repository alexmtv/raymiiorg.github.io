<!-- nominify -->



    <!DOCTYPE html>
    <html lang="en">
        <head>
        <title>Solve word puzzles with bash - Raymii.org</title>
        <link href="/s/inc/css/custom-first.css" rel="stylesheet" />
        <link href="/s/inc/css/light.css" rel="stylesheet"  />
        <link href="/s/inc/css/custom.css" rel="stylesheet" title="custom" />
        <script src="/s//inc/js/toc.js" type="text/javascript"></script>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <link href="inc/img/icons/iphone.png" rel="apple-touch-icon" />
        <link href="inc/img/icons/ipad.png" rel="apple-touch-icon" sizes="76x76" />
        <link href="inc/img/icons/iphone-retina.png" rel="apple-touch-icon" sizes="120x120" />
        <link href="inc/img/icons/ipad-retina.png" rel="apple-touch-icon" sizes="152x152" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link type="application/opensearchdescription+xml" rel="search" href="/s/inc/opensearch.xml"/>
        <link rel="alternate" type="application/rss+xml" title="RSS Feed for Raymii.org" href="https://raymii.org/s/feed.xml" />
    </head>
    <body>
        <a id="top-of-page"></a>
        <div class="container-fluid ">
            <div class="row">
                <div class="col-md-12">
                    <div class="col-md-3 col-sm-3 max-200">
                        <div class="well well-none"> 
                            <h3 class="headheader"><a href="https://raymii.org/s/">Raymii.org <img src="/s/inc/img/resistor-50.png" alt="IEC Resistor logo"></a></h3>
                            <h6 class="headheader">Quis custodiet ipsos custodes?</h6>
                            <h6><a href="https://raymii.org/s/feed.xml">RSS Feed</a></h6>
                        </div>
          

    
    <form role="search" action="https://encrypted.google.com/search">
        <div class="form-group">
          <input type="hidden" name="as_sitesearch" value="raymii.org">
          <input type="hidden" name="as_qdr" value="all">
          <input type="text" name="as_q" class="form-control" placeholder="Search">
        </div>
      </form>
      <div class="menu"><ul class="nav nav-pills nav-stacked"><li><a href="/s/index.html" class="special-menu">Home</a></li><li class='bottom-spacing'><a href="/s/everything.html" class="special-menu">All Pages</a></li><li class='hideifsmall'><a href="/s/tags/bash.html" class="link">Bash</a></li><li class='hideifsmall'><a href="/s/tags/monitoring.html" class="link">Monitoring</a></li><li class='hideifsmall'><a href="/s/tags/ssl.html" class="link">SSL</a></li><li class='hideifsmall'><a href="/s/tags/debian.html" class="link">Debian</a></li><li class='hideifsmall'><a href="/s/tags/python.html" class="link">Python</a></li><li class='hideifsmall'><a href="/s/tags/vpn.html" class="link">VPN</a></li><li class='hideifsmall'><a href="/s/tags/ubuntu.html" class="link">Ubuntu</a></li><li class='hideifsmall'><a href="/s/tags/nginx.html" class="link">nginx</a></li><li class='hideifsmall'><a href="/s/tags/openstack.html" class="link">Openstack</a></li><li class='hideifsmall'><a href="/s/tags/ansible.html" class="link">Ansible</a></li></ul>            
               <!-- advertisement start -->
                <a href="http://clients.inceptionhosting.com/aff.php?aff=083">Inception Hosting Affiliate Link</a><br />
                <a href="https://www.digitalocean.com/?refcode=7435ae6b8212">Digital Ocean Affiliate Link, $10 free credit.</a><br />
                <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                <!-- Raymii-2 -->
                <ins class="adsbygoogle"
                     style="display:inline-block;width:200px;height:200px"
                     data-ad-client="ca-pub-7993642564731324"
                     data-ad-slot="9322003332"></ins>
                <script>
                (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
                <!-- advertisement end -->
                </div>
           </div>  
           <div class="col-md-8 col-sm-8"> 
                <div class="inner">

           <h2 class='headheader'>Solve word puzzles with bash</h2><ul class="breadcrumb"><li><a href="../index.html" class="link">Home</a></li><li><a href="../articles/index.html" class="link">Articles</a></li><li><a href="Solve_word_puzzles_with_bash.html" class="link">Solve word puzzles with bash</a></li></ul><p><small>08-03-2015</small> | <small>Ben Everard</small></p><div class='ad'>
                            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                            <!-- voorartikel -->
                            <ins class="adsbygoogle"
                                 style="display:inline-block;width:728px;height:90px"
                                 data-ad-client="ca-pub-7993642564731324"
                                 data-ad-slot="6172324376"></ins>
                            <script>
                            (adsbygoogle = window.adsbygoogle || []).push({});
                            </script>
                        </div><br><div id="toc"><h3>Table of Contents</h3></div><hr><div id="contents"><p>This article was originaly published in <a href="http://www.linuxvoice.com/download-linux-voice-issue-1-with-audio/">Linux Voice, issue 1, April 2014</a>. This issue is now available under a <a href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons BY-SA license</a>. In a nutshell: you can modify and share all content from the magazine (apart from adverts), even for commercial purposes, providing you credit Linux Voice as the original source, and retain the same license.</p>

<p>This remix is converted manually to Markdown and HTML for ease of archiving and copy-pasting. </p>

<p>If you like this, please subscribe to Linux Voice. It is an awesome magazine with an awesome team of people. <a href="http://shop.linuxvoice.com/">Click here to subscribe</a> from just GBP 38 and get future issues straight to your door or inbox! (DRM Free PDF&#39;s and more available).</p>

<p>If you like this website and want to support it AND get $10 Digital Ocean credit (2 months free), use this link to order: <a href="https://www.digitalocean.com/?refcode=7435ae6b8212">https://www.digitalocean.com/?refcode=7435ae6b8212</a> (referral link).</p>

<p>Other converted Linux Voice articles <a href="https://raymii.org/s/tags/linux-voice.html">can be found here</a>. </p>

<hr>

<p>The humble command line interface is amazingly powerful, for both real work and playing games.</p>

<h3>Why do this?</h3>

<ul>
<li>Get to grips with egrep and extended regular expressions.</li>
<li>Never get stuck on word puzzles again.</li>
<li>Search through all the text files on your system with ease.</li>
</ul>

<h3>Solve word puzzles with Bash</h3>

<p>It&#39;s no secret that Bash, the shell on most Linux systems, is an incredibly powerful tool, however it&#39;s one that many Linux users don&#39;t take the time to fully learn. A lot of tutorials focus on boring but practical uses like managing log files, but it doesn&#39;t have to be this way. Bash can be fun. </p>

<p>Here at Linux Voice, we want to give this tool some love, so we&#39;re inaugurating the Grep Games. This is an event where you use Bash together with grep to solve the sort of word puzzles you find in glossy magazines.</p>

<p>Here&#39;s an example: what is <code>aedh</code> an anagram of? To solve this, you&#39;re going to need a list of English words. This comes as standard on most Linuxes, and can usually be found at <code>/usr/share/dict/words</code> or <code>/usr/dict/words</code>. If it&#39;s not there, check for a words or wordlist package in your package manager. Failing that, you can grab it from the DVD or <a href="http://linuxvoice.com">linuxvoice.com</a>. </p>

<p>In this article, we&#39;ll use <code>/usr/share/dict/words</code>, but you should change this if your words file is elsewhere. We&#39;ll use egrep (like grep but uses extended regular expressions, which have a cleaner syntax than plain regular explessions) to find the right words. If you haven&#39;t come across this tool before, take a look at the boxout on grep and regular expressions, right.</p>

<p>You can find any word that contains just the letters <code>aedh</code> with this line: </p>

<pre><code>egrep &quot;^[aedh]*$&quot; /usr/share/dict/words 
</code></pre>

<p>The <code>^</code> matches the start of the line, <code>$</code> the end of the line and <code>[aedh]*</code> matches any string of the letters <code>aedh</code>. </p>

<p>However, these aren&#39;t all anagrams. Any anagram must be exactly four letters long, so let&#39;s only match words of exactly four characters: </p>

<pre><code>egrep &quot;^[aedh]{4}$&quot; /usr/share/dict/words 
</code></pre>

<p>This is a bit better, but there are still some with repeated characters. To solve this we&#39;re going to pipe the output into a second instance of egrep, like this: </p>

<pre><code>egrep &quot;^[aedh]{4}$&quot; /usr/share/dict/words | egrep -v &quot;(.).*\1&quot; 
</code></pre>

<p>If you run this, you&#39;ll find that it only returns one line, the anagram of <code>aedh</code>. The second egrep has the <code>-v</code> flag, which means that it works in reverse; that is, it only outputs lines that don&#39;t match the pattern.</p>

<p>The pattern <code>(.).*\1</code> matches any line with a repeated character in it because <code>(.)</code> matches any character, <code>.*</code> matches any string of any length (including nothing) and <code>\1</code> is a back reference to the first character. For more details on this, see backreferences in the boxout on Grep and regular expressions. </p>

<p>Sometimes an anagram will contain a repeated letter, and that would be missed by the above. Take, for example, <code>eeeddh</code>. The previous method won&#39;t work, so instead we need to match different letters different numbers of times. The code for this is: </p>

<pre><code>egrep &quot;^[edh]{6}$&quot; /usr/share/dict/words | egrep &quot;*^[^e]*(e[^e]*) {3}[^e]*$&quot; | egrep &quot;^[^d]*(d[^d]*){2}[^d]*$&quot; | egrep -v &quot;([^ed]).*\1]*&quot; 
</code></pre>

<p>Here the second and third egreps both work in the same way. They make sure that a particular letter is repeated exactly a certain number of times. </p>

<p><code>[^e]</code> matches any character except <code>e</code>, so the second egrep matches any string that starts at a new line, has any character other than a letter <code>e</code> zero or more times followed by three occurrences of the bracketed expression (which contains <code>e</code> once and any string of other characters), then anything that isn&#39;t an e zero or more times followed by an end of line. </p>

<p>The final egrep makes sure that nothing other than <code>e</code> and <code>d</code> are repeated.</p>

<p><img src="https://raymii.org/s/inc/img/linuxvoice/1/regex101.png" alt="regex101"></p>

<blockquote>
<p><a href="http://www.regex101.com">www.regex101.com</a> is an online tool to help you understand regular expressions. Unfortunately it uses regular expressions from PHP, Python and JavaScript, which are slightly different from egrep. </p>
</blockquote>

<h3>I&#39;ll have a vowel please Carol</h3>

<p>This solves complete anagrams, but that&#39;s not always what you want to do. In the UK there&#39;s a quiz show called Countdown, in which the contestants have to make the longest word they can out of a given sequence of nine letters. </p>

<p>You can solve this in a similar manner to the above problem, but by using ranges for the number of characters rather than an absolute number. </p>

<p>Take a look at this example for the letters <code>a,e,e,f,d,m,t,t,i</code>:</p>

<pre><code>egrep &quot;^[aefdmti]{1,9}$&quot; /usr/share/dict/words | egrep &quot;*^[^e]*(e[^e]*){0,2}[^e]*$&quot; | egrep &quot;^[^t]*(t[^t]*){0,2}[^t]*$&quot; | egrep -v &quot;([^et]).*\1] 
</code></pre>

<p>However, this doesn&#39;t quite solve our problem. We don&#39;t want all the words that match, just the longest one. </p>

<p>To get this, we need to go beyond a single line and create a script. </p>

<pre><code>#!/bin/bash 
longestLength=0 
longestWord=&quot;&quot; 
while read word 
do 
  if (( ${#word} &gt; longestLength )) 
  then 
    longestLength=${#word} 
    longestWord=$word 
  fi 
done 
echo $longestWord 
</code></pre>

<p>This code reads each line from standard in (<code>while read line</code>) and checks its length against the previous longest word. At the end, it echos (prints) the longest word its found. </p>

<p>To include this with the previous egrep commands, just use: </p>

<pre><code>egrep &quot;^[aefdmnti]{1,9}$&quot; /usr/share/dict/words | egrep &quot;*^[^e]*(e[^e]*){0,2}[^e]*$&quot; | egrep &quot;^[^t]*(t[^t]*){0,2}[^t]*$&quot; | egrep -v &quot;([^et]).*\1]*&quot; | bash longest.sh 
</code></pre>

<p>Where <code>longest.sh</code> is the filename of the above script (it&#39;s on the website and DVD). </p>

<p>Another puzzle similar to Countdown is the word wheel. This is where there&#39;s a series of letters on the outside of a circle and one in the middle. You then have to find as many words as possible that contain the letter in the middle and two or more of the letters on the outside. </p>

<p><img src="https://raymii.org/s/inc/img/linuxvoice/1/wordwheel.png" alt="wordwheel"></p>

<blockquote>
<p>Word wheels: a challenging mental puzzle or a simple command?</p>
</blockquote>

<p>The example puzzle on the facing page can be solved with:</p>

<pre><code>egrep &quot;^[fedpt]*i[fedpt]*$&quot; /usr/share/dict/words | egrep -v &quot;(.).*\1&quot; | egrep &quot;.{3,}&quot; 
</code></pre>

<p><img src="https://raymii.org/s/inc/img/linuxvoice/1/gvim.png" alt="gvim"></p>

<blockquote>
<p>Many programs have some form of regexes built in. Here, gvim is finding all USB messages for user ben in the syslog.</p>
</blockquote>

<p>Word ladders are a bit different to the puzzles we&#39;ve looked at so far. Instead of arranging various letters into words, you start with a word, then each rung of the ladder you change a single letter from the word above until you end up with a final word. </p>

<p>There are two separate parts to look at. The first part is finding all the words that can follow a particular word. The second part is finding out if a particular word can precede the final word. </p>

<p>Let&#39;s try the ladder: </p>

<pre><code>live 
---- 
---- 
---- 
raft 
</code></pre>

<p>To solve this you have to come up with three words. </p>

<pre><code>#!/bin/bash 
for x in $(egrep &quot;^liv.$|^li.e$|^l.ve$|^.ive$&quot; /usr/share/dict/words); do 
  query=&#39;^.&#39;${x:1:3}&#39;$|^&#39;${x:0:1}&#39;.&#39;${x:2:2}&#39;$|^&#39;${x:0:2}&#39;.&#39;${x:3:1}&#39;$| ^&#39;${x:0:3}&#39;.$&#39; 
  for y in $(egrep $query /usr/share/dict/words); do 
    query2=&#39;^.&#39;${y:1:3}&#39;$|^&#39;${y:0:1}&#39;.&#39;${y:2:2}&#39;$|^&#39;${y:0:2}&#39;.&#39;${y:
3:1}&#39;$|^&#39;${y:0:3}&#39;.$&#39;
    for z in $(egrep $query2 /usr/share/dict/words | egrep &quot;^raf.$|^ra.t$|^r.ft$|^.aft$&quot;); do
      if [ $x != $y ] &amp;&amp; [ $x != $z ] &amp;&amp; [ $x != &quot;live&quot; ] &amp;&amp; [ $x != &quot;raft&quot; ] &amp;&amp; [ $y != $z ] &amp;&amp; [ $y != &quot;live&quot; ] &amp;&amp; [ $y != &quot;raft&quot; ] &amp;&amp; [ $z != &quot;live&quot; ] &amp;&amp; [ $z != &quot;raft&quot; ]; then 
        echo &quot;live&quot;
        echo $x
        echo $y 
        echo $z 
        echo &quot;raft&quot; 
        echo &quot;---&quot;
      fi
    done
  done
done
</code></pre>

<p>This code performs three for loops, one for each of the missing words. The first for loop runs on every word that matches the regular expression <code>&quot;^liv.$|^li. e$|^l.ve$|^.ive$&quot;</code> this is effectively four different regular expressions separated by <code>|</code>. Together, it will return any word that matches any one of these sub-expressions. </p>

<p>Inside this for loop it runs the line:</p>

<pre><code>query=&#39;^.&#39;${x:1:3}&#39;$|^&#39;${x:0:1}&#39;.&#39;${x:2:2}&#39;$|^&#39;${x:0:2}&#39;.&#39;${x:3:1}&#39;$|^&#39;$ {x:0:3}&#39;.$&#39; 
</code></pre>

<p>This just builds up a regular expression equivalent to the first one but for every word returned. <code>x</code> is the variable holding the word, and <code>${x:1:3}</code> (for example) returns characters 1 through 3 of the word held in variable <code>x</code> (the first character is 0). </p>

<p>The second for loop works in exactly the same way as the first. The final for loop is a bit different because it not only has to match the word above it, but the word below it as well. For this reason it runs two egreps on the words: one to match the words above, and the second to match the words below. The if statement simply removes any solutions that repeat words.</p>

<p><img src="https://raymii.org/s/inc/img/linuxvoice/1/egrep.png" alt="egrep"></p>

<blockquote>
<p>egrep will highlight the particular part of each line that matches the regular expression.</p>
</blockquote>

<h3>Playing GCHQ</h3>

<p>Substitution ciphers are easy-to-break encryption systems where you take each letter of the alphabet and represent it with a different symbol. The point of the puzzle is to work out what letters the symbols represent. </p>

<p>As an example, the cipher: </p>

<pre><code>12334, 56 7852 90 a27 
</code></pre>

<p>could correspond to: </p>

<pre><code>hello, my name is ben 
</code></pre>

<p>because </p>

<pre><code>h=1, e=2, l=3, o=4, m=5, y=6, n=7, a=8, i=9, b=a. 
</code></pre>

<p>Now take a look at the following: </p>

<pre><code>123452 672 8298a2 bc 9889dbeb9c 
</code></pre>

<p>The main clue here are repeated letters which you can match using back references. You could try to build a script to match the whole lot in one go, but it&#39;s far easier and quicker to pick on part with quite a few repeated characters and just match that. </p>

<p>Once you&#39;ve got that, it should be quite trivial to finish it off. We decided to work with the final two words. A script to solve them is: </p>

<pre><code>#!/bin/bash 
list2=$(egrep &quot;(.)(.)\2\1.(.).\3\1.&quot; /usr/share/dict/words) 
for word1 in $(egrep &quot;^.{2}$&quot; /usr/share/dict/words); do 
  for word2 in $list2; do 
    echo $word1&quot; &quot;$word2 | egrep &quot;^(.)(.) [[:space:]](.)(.)\4\3.\1.\1\3\2$&quot; 
  done 
done 
</code></pre>

<p>The first loop goes through every two letter word while the second one loops through every word that matches the particular pattern of backreferences. </p>

<p>The guts of the code is the line: </p>

<pre><code>echo $word1&quot; &quot;$word2 | egrep &quot;^(.)(.)[[:space:]](.) (.)\4\3.\1.\1\3\2$&quot; 
</code></pre>

<p>It checks every pair of words generated by the two loops for a particular pattern of back references which correspond to repeated characters in the ciphertext. </p>

<p>This method could be expanded to match three or more words, though it will slow down significantly with each new word. Once you&#39;ve got some of the letters, you should be able to come up with patterns based on the letters you know to find the other words.</p>

<blockquote>
<p>Ben Everard is the co-author of Learning Python with Raspberry Pi, soon to be published by Wiley. He&#39;s also pretty good at turning foraged fruit into alcohol.</p>
</blockquote>

<h3>Boxout 1: Grep and regular expressions</h3>

<p>Grep is a popular tool for finding particular pieces of text. As well as solving word games, it&#39;s also useful in finding particular messages in log files and other &#39;real&#39; work. </p>

<p>egrep is like grep, but it uses extended regular expressions rather than ordinary regular expressions. These have a cleaner syntax, so it&#39;s these that we&#39;ll use here. The basic usage is: </p>

<pre><code>egrep &lt;pattern&gt; &lt;file&gt; 
</code></pre>

<p>This will output every line in the file that matches <code>&lt;pattern&gt;</code>. It can also be used in a pipe like this: </p>

<pre><code>cat &lt;file&gt; | egrep &lt;pattern&gt; 
</code></pre>

<p>This just prints every line that cat outputs that matches <code>&lt;pattern&gt;</code>. The trick with egrep is in mastering extended regular expressions. A letter just matches itself, so for example, <code>abc</code> will match any line that contains the string abc anywhere in it. </p>

<p><code>^</code> matches the start of the line and <code>$</code> matches the end of the line, so <code>^abc</code> matches any line that starts with <code>abc</code>, <code>abc$</code> matches any line that ends with <code>abc</code> and <code>^abc$</code> matches any line that contains just <code>abc</code>. </p>

<p>The <code>.</code> character matches any character, so <code>^a.c$</code> will match <code>abc</code>, <code>adc</code>, <code>aac</code>, but not <code>ac</code>. This is known as backreferencing. You can also match groups of characters, eg <code>^[ab]</code> will match any line that starts with <code>a</code> or <code>b</code>, while <code>^[^ab]</code> will match any line that starts with any character other than <code>a</code> or <code>b</code>. </p>

<p><code>^[a-z]</code> will match any line starting with a lower-case letter. There are also a few special options here such as <code>[[:space:]]</code>, which matches any whitespace (space, tab, etc) and <code>[[:lower:]]</code> which matches any lower-case letter. </p>

<p>You can match characters more than once. <code>*</code> matches zero or more times, <code>+</code> one or more time, and <code>?</code> zero or one time. So, <code>^a*$</code> matches a line that contains a number of <code>a&#39;s</code> but no other characters. <code>^a.*a$</code> matches a line that starts and finishes with a letter a. <code>^a.+a$</code> matches any line that starts and ends with an a and has at least one character in between. </p>

<p>You can also specify a range of the number of matches you want by using <code>{}</code>. For example, <code>^a{2,3}$</code> will match the lines <code>aa</code> and <code>aaa</code>, but nothing else. You can bracket parts of regular expressions as well. This is useful because it allows you to refer to particular matches. </p>

<p><code>\1</code> matches whatever the first bracketed expression matched, <code>\2</code> matches what the second matched and so on. For example, <code>(.).\1</code> will match any two characters that are the same separated by a character, such as <code>bob</code>, <code>did</code>, <code>aaa</code>, but not <code>abc</code>. </p>

<p>The final part of extended regular expressions that we&#39;ll look at is <code>|</code>. This allows you to match against more than one pattern. For example, <code>^ab|^bc</code> will match anything that starts with either <code>ab</code> or <code>bc</code>, but not <code>ac</code> or anything else. <code>^(ab|bc)</code> does the same thing.</p>

<h3>Challenges</h3>

<p>Test your skills by writing scripts to solve the following word puzzles.</p>

<h4>Anagrams</h4>

<ul>
<li>ainpprss</li>
<li>abeprrrsy</li>
<li>bbceirssu</li>
</ul>

<h4>Countdown</h4>

<ul>
<li>tnxpamies</li>
<li>dimtescat</li>
<li>hofanescp</li>
</ul>

<h4>Encryption</h4>

<ul>
<li>1 2134 567894550 518824 1a4 a546b4</li>
<li>1234 34 5641 127 879300309</li>
<li>123 456 4 378936 8708a8034b</li>
</ul>

<h4>Word Wheel</h4>

<p><img src="https://raymii.org/s/inc/img/linuxvoice/1/wordwheel4.png" alt="wordwheel" ></p>

<p><img src="https://raymii.org/s/inc/img/linuxvoice/1/wordwheel3.png" alt="wordwheel" ></p>

<p><img src="https://raymii.org/s/inc/img/linuxvoice/1/wordweel2.png" alt="wordwheel" ></p>

<h4>Word ladder</h4>

<p>First:</p>

<pre><code>band
----
----
----
meat
</code></pre>

<p>Second:</p>

<pre><code>brag
----
----
----
plan
</code></pre>

<p>Third:</p>

<pre><code>wire
----
----
----
pant
</code></pre>
</div><hr>Tags: <a href="../tags/anagram.html" class="link">anagram, </a><a href="../tags/bash.html" class="link">bash, </a><a href="../tags/dict.html" class="link">dict, </a><a href="../tags/egrep.html" class="link">egrep, </a><a href="../tags/grep.html" class="link">grep, </a><a href="../tags/linux-voice.html" class="link">linux-voice, </a><a href="../tags/linux-voice-issue-1-2014.html" class="link">linux-voice-issue-1-2014, </a><a href="../tags/regex.html" class="link">regex, </a><div class="footer">
                <hr>
                <p>Generated by <a href="/s/software/ingsoc.html">ingsoc</a> | 
                <a href="/s/software/Sparkling_Network.html">Cluster Status</a> | 
                <a href="/s/static/About.html">About</a><br />
                </div>
            </div>
        </div>
    </div>  
    </div>
    </div>
     
    <!-- Piwik --> 
    <script type="text/javascript">
    var pkBaseURL = (("https:" == document.location.protocol) ? "https://hosted-oswa.org/piwik/" : "http://hosted-oswa.org/piwik/");
    document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
    </script><script type="text/javascript">
    try {
    var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 1);
    piwikTracker.trackPageView();
    piwikTracker.enableLinkTracking();
    } catch( err ) {}
    </script><noscript><p><img src="http://hosted-oswa.org/piwik/piwik.php?idsite=1" style="border:0" alt="" /></p></noscript>
    <!-- End Piwik Tracking Code -->
    </body>
    </html>
    