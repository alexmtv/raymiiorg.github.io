<!-- nominify -->



    <!DOCTYPE html>
    <html lang="en">
        <head>
        <title>Building HA Clusters with Ansible and Openstack - Raymii.org</title>
        <link href="/s/inc/css/light.css" rel="stylesheet" title="light" />
        <link href="/s/inc/css/dark.css" rel="alternate stylesheet" title="dark" />
        <script src="/s/inc/js/jquery-2.1.1.min.js"></script>
        <script src="/s/inc/js/bootstrap.3.2.0.min.js"></script>
        <script src="/s/inc/js/styleswitcher.js"></script>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <link href="inc/img/icons/iphone.png" rel="apple-touch-icon" />
        <link href="inc/img/icons/ipad.png" rel="apple-touch-icon" sizes="76x76" />
        <link href="inc/img/icons/iphone-retina.png" rel="apple-touch-icon" sizes="120x120" />
        <link href="inc/img/icons/ipad-retina.png" rel="apple-touch-icon" sizes="152x152" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link type="application/opensearchdescription+xml" rel="search" href="/s/inc/opensearch.xml"/>
        <link rel="alternate" type="application/rss+xml" title="RSS Feed for Raymii.org" href="http://feeds.feedburner.com/Raymiiorg" />
    </head>
    <body>
        <a id="top-of-page"></a>
        <div class="container-fluid ">
            <div class="row">
                <div class="col-md-12">
                    <div class="col-md-3 col-sm-3 max-200">
                        <div class="well well-none"> 
                            <h3 class="headheader"><a href="https://raymii.org/s/">Raymii.org <img src="https://raymii.org/s/inc/img/resistor-50.png" alt="IEC Resistor logo"></a></h3>
                            <h6 class="headheader">Quis custodiet ipsos custodes?</h6>
                            <h6><a href="http://feeds.feedburner.com/Raymiiorg">RSS Feed</a></h6>
                        </div>
          

    
    <form role="search" action="https://encrypted.google.com/search">
        <div class="form-group">
          <input type="hidden" name="as_sitesearch" value="raymii.org">
          <input type="hidden" name="as_qdr" value="all">
          <input type="text" name="as_q" class="form-control" placeholder="Search">
        </div>
      </form>
      <div class="menu"><ul class="nav nav-pills nav-stacked"><li><a href="/s/index.html" class="special-menu">Home</a></li><li class='bottom-spacing'><a href="/s/everything.html" class="special-menu">All Items</a></li><li><a href="/s/tags/bash.html" class="link">Bash</a></li><li><a href="/s/tags/monitoring.html" class="link">Monitoring</a></li><li><a href="/s/tags/ssl.html" class="link">SSL</a></li><li><a href="/s/tags/debian.html" class="link">Debian</a></li><li><a href="/s/tags/python.html" class="link">Python</a></li><li><a href="/s/tags/vpn.html" class="link">VPN</a></li><li><a href="/s/tags/ubuntu.html" class="link">Ubuntu</a></li><li><a href="/s/tags/nginx.html" class="link">nginx</a></li><li><a href="/s/tags/apache.html" class="link">Apache</a></li><li><a href="/s/tags/ansible.html" class="link">Ansible</a></li></ul>
                <ul class="navbar-collapse nav navbar-nav">
                <li class="dropdown">
                <a data-toggle="dropdown" class="dropdown-toggle" href="#">Style<b class="caret"></b></a>
                <ul class="dropdown-menu">
                <li><a href="#" onclick="setActiveStyleSheet('dark')">Dark</a></li>
                <li><a href="#" onclick="setActiveStyleSheet('light')">Light</a></li>
                </ul>
                </li>
                </ul>
                <br><br>
               <!-- advertisement start -->
                <a href="http://clients.inceptionhosting.com/aff.php?aff=083">Inception Hosting Affiliate Link</a><br />
                <a href="https://www.digitalocean.com/?refcode=7435ae6b8212">Digital Ocean  Affiliate Link</a><br />
                <script type="text/javascript"><!--
                google_ad_client = "ca-pub-7993642564731324";
                google_ad_slot = "9322003332";
                google_ad_width = 200;
                google_ad_height = 200;
                //-->
                </script>
                <script type="text/javascript"
                src="//pagead2.googlesyndication.com/pagead/show_ads.js">
                </script>    
                <!-- advertisement end -->
                </div>
           </div>  
           <div class="col-md-8 col-sm-8"> 
                <div class="inner">

           <h2 class='headheader'>Building HA Clusters with Ansible and Openstack</h2><ul class="breadcrumb"><li><a href="../index.html" class="link">Home</a></li><li><a href="../articles/index.html" class="link">Articles</a></li><li><a href="Building_HA_Clusters_With_Ansible_and_Openstack.html" class="link">Building HA Clusters with Ansible and Openstack</a></li></ul><p><small>25-07-2014</small> | <small>Remy van Elst</small></p><div class='ad'>
                            <script type="text/javascript"><!--
                            google_ad_client = "ca-pub-7993642564731324";
                            /* voorartikel */
                            google_ad_slot = "6172324376";
                            google_ad_width = 728;
                            google_ad_height = 90;
                            //-->
                            </script>
                            <script type="text/javascript"
                            src="//pagead2.googlesyndication.com/pagead/show_ads.js">
                            </script>
                        </div><br><p>This is an extensive guide on building high available clusters with Ansible and Openstack. We&#39;ll build a Highly available cluster consisting out of two load balancers, two database servers and two application servers. This is all done with Ansible, the cluster nodes are all on Openstack. Ansible is a super awesome orchestration tool and Openstack is a big buzzword filled software suite for datacenter virtualization.</p>

<h3>Summary</h3>

<p><img src="https://raymii.org/s/inc/img/openstack-cluster.png" /></p>

<p>This image represents the setup we will create. It will be a simple, data center redundant high available cluster. The tutorial sets up two nginx frontend load balancers with keepalived failover, two mysql database servers with master-master replication and keepalived failover and two application servers with apache and php plus glusterfs for file syncronization.</p>

<p>We&#39;ll create and provision these VM&#39;s fully with Ansible combined with the magic of Openstack. </p>

<p>Openstack has the concept of Availability Zones. Your can see this as multiple, physically independent networks which are logically able to communicate. Most Cloud providers call them seperate Data centers or Regions. If your Cloud provider has set it up correctly, the Openstack Cloud, and thus your cluster, will survive one full datacenter failing. </p>

<p>This tutorial sets up Wordpress as the application, but it can be easily adapted for any other cluster setup.</p>

<p>I&#39;m using the Openstack Cloud from <a href="https://cloudvps.com">CloudVPS</a>, but any Openstack cloud will do. CloudVPS is the best one though, in my opinion. The screenshots you&#39;ll see are not of the default Openstack dashboard but of the CloudVPS Skyline Openstack Interface.</p>

<p>This playbook and tutorial are easily adaptable for another cloud provider like <a href="https://www.digitalocean.com/?refcode=7435ae6b8212">Digital Ocean (aff. link)</a>, Rackspace (Openstack) or Vultr. I however prever the openness of Openstack, if one Openstack provider throws the towel, my &quot;cloud&quot; applications will be redeployed in another Openstack Cloud without issues. <a href="https://www.digitalocean.com/?refcode=7435ae6b8212">Digital Ocean</a> does not provide that benefit.</p>

<p>The playbook can be found <a href="https://github.com/RaymiiOrg/ansible/tree/master/openstack-example">in this git repository</a>.</p>

<h3>Openstack Preparations</h3>

<p>We need to do a few things before we can start.</p>

<h4>Set up a manager host</h4>

<p><img src="https://raymii.org/s/inc/img/skyline-hosts.png" alt="network" /></p>

<p>We will create all the nodes in a private network, unreachable from the internet. To access all hosts we need a manager vm where we can run ansible and debug if needed.</p>

<p>Create a VM in Openstack, I&#39;ll create an Ubuntu 14.04 VM and install Ansible on it. Give it an internal IP in that network and associate a floating IP with that to make sure you can SSH in.</p>

<p>Install the packages required for building Ansible:</p>

<pre><code>apt-get install python-pip python-dev
</code></pre>

<p>Install the latest Ansible:</p>

<pre><code>pip install ansible
</code></pre>

<p>Install the openstack nova client:</p>

<pre><code>pip install python-novaclient
</code></pre>

<p>Copy the playbook over and edit the <code>vars/main.yml</code> file with your two port IP&#39;s and your Openstack credentials and your passwords. </p>

<p>Create a <code>ansible_hosts</code> file with the following contents:</p>

<pre><code>[localhost]
127.0.0.1
</code></pre>

<p>The combination of Openstack and Ansible will create all the hosts and make them dynamically available to us for use within the playbook.</p>

<h4>Creating a network</h4>

<p>Use the GUI or CLI to create a network with routing/NAT and DHCP. Note down the network ID and the subnet ID. The network ID must be changed in the Playbook Variables.</p>

<p><img src="https://raymii.org/s/inc/img/skyline-graph.png" alt="network" /></p>

<h4>Network ports for keepalived and floating IP</h4>

<p>Create two floating IP&#39;s. Attach one to the Ansible Manager host.</p>

<p>Ask your Openstack provider to create two ports in your private network for the two keepalived configurations. Also ask them to associate the floating IP with one of the ports.</p>

<p><img src="https://raymii.org/s/inc/img/skyline-floating-ips.png" alt="keepalived" /></p>

<p>These actions must be done by an Openstack admin (as of IceHouse). What they will do is create two ports in the private network with the choosen IP addresses we will use for Keepalived. The VM&#39;s in this network can bind and use these addresses. The floating IP will be associates with one of the ports so that we can bind and fail over the load balancers with one external (and internal) IP. The commands look like this:</p>

<pre><code>neutron port-create NETWORK-UUID --fixed_ip subnet_id=SUBNET-UUID,ip_address=PREFERED_INTERNAL_IPv4 --tenant-id YOUR_TENANT_ID

neutron floatingip-associate FLOATING_IP_UUID PORT_UUID 
</code></pre>

<p>The port-create should be done two times since we&#39;ll use keepalived on the database servers and on the load balancers.</p>

<p>The two ports will be listed as &quot;DOWN&quot;, even when they are not.</p>

<p><img src="https://raymii.org/s/inc/img/skyline-network.png" alt="network" /></p>

<p>I&#39;ll cover all the different parts of the playbook before we run it. Let&#39;s start with the Host Creation.</p>

<h3>Variable setup</h3>

<p>Make sure you edit the <code>vars/main.yml</code> file. Change your authentication data, the HA IP addresses to the ones you received from your Openstack provider. Here are the most important things to change:</p>

<pre><code>---
auth_url: https://identity.stack.cloudvps.com/v2.0  
image_id: 
private_net: 

keypair_name: SSH_Key
website_name: &quot;example.org&quot;
mysql_user: &quot;app&quot;
mysql_password: &quot;FINE2yfUIt&quot;

keepalived_sql_vip: &quot;10.107.244.210&quot;
keepalived_sql_router_id: &quot;60&quot;
keepalived_sql_passwd: &quot;cc2BgJiGAbAoSlks&quot;

keepalived_lbs_vip: &quot;10.107.244.200&quot;
keepalived_lbs_router_id: &quot;50&quot;
keepalived_lbs_passwd: &quot;m9RwFk3Mx&quot;
</code></pre>

<h3>Host Creation</h3>

<p>We&#39;ll use the ansible nova_compute module to create all the required hosts. You should have adapted the variables file with the parameters for your Openstack Cloud, in this example we will create 6 hosts:</p>

<ul>
<li>2 load balancers running nginx and keepalived</li>
<li>2 database servers running mysql in master-master</li>
<li>2 app servers running apache and php, plus glusterfs for the file sync</li>
</ul>

<p>All the example servers run Ubuntu 14.04.</p>

<p>One of each these servers will be in Availability Zone NL1 and one in zone NL2. If your Openstack Provider has Availability Zones and you use them correctly then your cluster will be protected against one whole data center (Availability Zone) loss. </p>

<p>I&#39;ve added the Availability Zone selection code to Ansible 1.7, <a href="https://github.com/ansible/ansible/pull/8182">see this pull request</a>. Make sure you run at least Ansible 1.7, otherwise it will complain about not knowing the parameter. You can also just comment out the availability zone parameter, apply the patch yourself or run the &quot;devel&quot; branch of Ansible (when it is merged).</p>

<p>The play consists out of 6 times the following, one for each host:</p>

<pre><code># tasks/create-instances.yml
- nova_compute:
    auth_url: &quot;{{ auth_url }}&quot;
    login_username: &quot;{{ login_username }}&quot;
    login_password: &quot;{{ login_password }}&quot;
    login_tenant_name: &quot;{{ login_tenant_name }}&quot;
    security_groups: &quot;built-in-allow-all&quot;
    state: present
    availability_zone: &quot;NL2&quot;
    name: ansible-cluster-lb1
    image_id: &quot;{{ image_id }}&quot;
    key_name: &quot;{{ keypair_name }}&quot;
    wait_for: 500
    nics:
      - net-id: &quot;{{ private_net }}&quot;
    flavor_id: &quot;{{ flavor_id }}&quot;
    meta:
      hostname: ansible-cluster-lb1
      group: ansible
  register: openstacklb1

- add_host: 
    name: &quot;{{ openstacklb1.private_ip }}&quot; 
    groupname: lbs 
    keepalived_lbs_prio: 150
</code></pre>

<p>We give all the nodes only Internal IP addresses. Since we have a network with NATing and a router they will all be able to access the internet. All communication will go via the earlier created manager node, and all web traffic will go via the virtual/Floating IP.</p>

<p>Make sure you have ssh key forwarding set up. Make sure you have uploaded your SSH key to Openstack. Check all variables and match them with your Openstack Cloud. (Image ID, flavor ID etc.)</p>

<p>After the instance has been created we add the host to a new hostgroup, according to the role it will be in <code>app</code>, <code>lbs</code> or <code>dbs</code>. We also, per host when applicable, give the keepalived priority and the mysql server ID as Ansible Variables. These will be used later on in the playbook run.</p>

<p>All hosts should be created by Ansible. Openstack will give them an IP and Ansible registers that IP for use in a later play.</p>

<h3>Configuring Loadbalancers</h3>

<p><img src="https://raymii.org/s/inc/img/nginx-alt.png" a;t="keepalived" /></p>

<p>Our load balancer configuration consists out of two nginx servers with a reverse proxy configuration to both app servers. They are connected to each other via keepalived and this, if one fails, the other will take over. Because the keepalived virtual IP is also associated to the floating IP, it wil automatically work for that as well.</p>

<p>This play is configured to gather facts on both the <code>lbs</code> group and the <code>app</code> group, but only runs tasks on the <code>lbs</code> group. </p>

<p>We need to do this because we need facts from the <code>app</code> group to configure nginx, but Ansible only gathers facts from hosts in the play. </p>

<p>We therefore cannot run the playbook just on the load balancer nodes. We also don&#39;t want to do any actions in on the app nodes, just the facts. </p>

<p>You can define multipe groups where a playbook should run with the <code>:</code> as you can see below, we run on <code>lbs:app</code>. The <code>when</code> statement makes sure the actual playbook only runs on the nodes in the <code>lbs</code> group.</p>

<pre><code># tasks/main.yml
- name: Configure LoadBalancers
  hosts: lbs:app
  vars_files:
    - &quot;vars/main.yml&quot;
  user: root
  tasks:
    - include: tasks/configure-lbs.yml
      when: &#39;&quot;{{ inventory_hostname }}&quot; in &quot;{{ groups.lbs }}&quot;&#39;
    - include: tasks/keepalived.yml
      when: &#39;&quot;{{ inventory_hostname }}&quot; in &quot;{{ groups.lbs }}&quot;&#39;
</code></pre>

<h4>nginx setup</h4>

<p>We start by adding the nginx stable PPA so that we have the latest version of nginx available:</p>

<pre><code># tasks/configure-lbs.yml
---
- apt_repository: 
    repo: &#39;ppa:nginx/stable&#39;
    state: present
    update_cache: yes
</code></pre>

<p>We install nginx, vim, git and ntp. The first is the load balancer itself, the next two are tools I frequently use and the last is important, out-of-sync time can cause weird cluster issues.</p>

<pre><code>- apt: 
    name: &quot;{{ item }}&quot; 
    state: latest 
    update_cache: yes
  with_items:
    - nginx
    - vim
    - git
    - ntp
</code></pre>

<p>The folder for the nginx cache is created:</p>

<pre><code>- file:
    dest: /var/cache/nginx
    state: directory
    owner: www-data
</code></pre>

<p>We then place the loadbalancer config:</p>

<pre><code>- template:
    src: nginx-lb.conf.j2
    dest: /etc/nginx/sites-available/lbs.conf
  register: confresult
  notify:
  - restart keepalived
</code></pre>

<p>The template file looks like this:</p>

<pre><code># templates/nginx.conf.j2
upstream backend  {
{% for host in groups[&#39;app&#39;] %}
    server {{ hostvars[host][&#39;ansible_eth0&#39;][&#39;ipv4&#39;][&#39;address&#39;] }}:80 max_fails=5  fail_timeout=5s;
{% endfor %}
}

proxy_cache_path /var/cache/nginx levels=1:2  keys_zone=CACHE:10m inactive=24h  max_size=1g;

server {
    listen          80  default_server;
    server_name     {{ website_name }};

    access_log  /var/log/nginx/{{ website_name }}.access.log;
    error_log   /var/log/nginx/{{ website_name }}.error.log;
    root        /usr/share/nginx/html;

    location / {
        proxy_pass              http://backend;
        proxy_next_upstream     error timeout invalid_header http_500 http_502 http_503 http_504;
        proxy_redirect          off;
        proxy_cache             CACHE;
        proxy_cache_valid       200  1d;
        proxy_cache_use_stale   error timeout invalid_header updating  http_500 http_502 http_503 http_504;
        proxy_set_header        Host            $host;
        proxy_set_header        X-Real-IP       $remote_addr;
        proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;
   }
}
</code></pre>

<p>As you can see it uses Jinja2 loops to add every app-server to the backend using this piece of logic:</p>

<pre><code>{% for host in groups[&#39;app&#39;] %}
    server {{ hostvars[host][&#39;ansible_eth0&#39;][&#39;ipv4&#39;][&#39;address&#39;] }}:80 max_fails=5  fail_timeout=5s;
{% endfor %}
</code></pre>

<p>If we want to spawn more app servers we can do that and they will be automatically configured here on the next ansible run.</p>

<p>This configuration will remove a backend server if it gives more than 5 non 2XX or 3XX HTTP status coedes or if it does not respond in 5 seconds. If one app server is down, the load balancer will not send more visitors to it.</p>

<pre><code>proxy_next_upstream error timeout invalid_header http_500 http_502 http_503 http_504;
</code></pre>

<p>This configuration also has caching enabled:</p>

<pre><code>proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=CACHE:10m  max_size=1g;
proxy_cache             CACHE;
proxy_cache_valid       200  1h;
proxy_cache_use_stale   error timeout invalid_header updating  http_500 http_502 http_503 http_504;
</code></pre>

<p>This will cache all data which was sent with a 200 response for 1 hour. All data that is cached but not accessed is removed from the cache after 10 minutes.</p>

<p>Make sure you send a <code>Cache-Control</code> header: <code>Cache-Control: max-age=900, must-revalidate</code> otherwise you might run into caching problems. Read the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec13.html">rfc here</a>. If you are unsure, turn it off.</p>

<p>We link the file to the <code>sites-enabled</code> folder, as a good practice:</p>

<pre><code>- file:
    src: /etc/nginx/sites-available/lbs.conf
    dest: /etc/nginx/sites-enabled/lbs.conf
    state: link
  notify:
  - restart keepalived
</code></pre>

<p>This means that when your fellow sysadmin removes the file in sites-enabled/ it will not be gone forever, but just disabled.</p>

<p>We make sure the default site is not running:</p>

<pre><code>- file:
    dest: /etc/nginx/sites-enabled/default
    state: absent
  notify:
  - restart keepalived
</code></pre>

<p>nginx is restarted when needed by the notify handler.</p>

<h4>keepalived setup</h4>

<p><img src="https://raymii.org/s/inc/img/keepalived-portal.png" a;t="keepalived" /></p>

<p>keepalived will provide basic IP failover. If one node fails the other will take over. Ansible will make sure the confituration everywhere is the same, and we have created a port and floating IP which will we connect visitors to so that in the case of a failover everything keeps working.</p>

<p>Keepalived is very simple to setup, <a href="https://raymii.org/s/tutorials/Keepalived-Simple-IP-failover-on-Ubuntu.html">I&#39;ve written an article about the setup on Ubuntu 14.04 which you should read</a>. </p>

<p>First we install keepalived on both nodes:</p>

<pre><code># tasks/keepalived.yml
---
- apt: 
    name: &quot;{{ item }}&quot; 
    state: latest 
    update_cache: yes
  with_items:
    - keepalived
</code></pre>

<p>We make sure linux can bind to an address not configured on an interface (the VIP, for example):</p>

<pre><code>- sysctl: 
    name: net.ipv4.ip_nonlocal_bind 
    value: &quot;1&quot; 
    state: present
    reload: yes
</code></pre>

<p>If we don&#39;t do that, keepalived will not work.</p>

<p>We place the config file. The playbook places a different config file for the load balancers and for the database servers, this because the Virtual IP, router ID and password are different for both configurations.</p>

<p>These values are used by Keepalived to determine the VIP, nodes and other configuration. We can run multiple keepalived instances in the same subnet, but we need to make sure they have a different ID and password.</p>

<pre><code>- template:
    src: keepalived.lbs.conf.j2
    dest: /etc/keepalived/keepalived.conf
  when: inventory_hostname in groups[&#39;lbs&#39;]
  notify:
  - restart keepalived

- template:
    src: keepalived.sql.conf.j2
    dest: /etc/keepalived/keepalived.conf
  when: inventory_hostname in groups[&#39;dbs&#39;]
  notify:
  - restart keepalived
</code></pre>

<p>You can check out the <a href="">git repository</a> to see the keepalived layout. Since it is fairly standard, I won&#39;t show it here.</p>

<p>Do note that it only protects against full host failure, not just failure of the webserver. That is some homework for you to figure out.</p>

<p>If the config has changed, we restart the keepalived service via the notify handler.</p>

<p>We now have configured the load balancers. Let&#39;s move on to the Database Servers.</p>

<h3>Database Cluster</h3>

<p><img src="https://raymii.org/s/inc/img/database-dilbert.png" /></p>

<p>Our database cluster will consist out of two MySQL servers running in Master Master mode. </p>

<p>This play runs on the two database servers Ansible created earlier:</p>

<pre><code># tasks/main.yml
- name: Configure Databases
  hosts: dbs
  vars_files:
    - &quot;vars/main.yml&quot;
  user: root
  tasks:
    - include: tasks/configure-dbs.yml
    - include: tasks/keepalived.yml
  handlers:
    - include: handlers/main.yml
</code></pre>

<h4>MySQL Master Master</h4>

<p>We start with installing MySQL and the python module Ansible needs for MySQL:</p>

<pre><code># tasks/configure-dbs.yml
---
- apt: 
    name=&quot;{{ item }}&quot; 
    state=latest 
    update_cache=yes
  with_items:
    - mysql-server
    - python-mysqldb
    - vim
    - git
    - ntp
</code></pre>

<p>We place our MySQL config file:</p>

<pre><code>- template:
    src: my.cnf.j2
    dest: /etc/mysql/my.cnf
  notify:
    - restart mysql
</code></pre>

<p>This is the config file:</p>

<pre><code># templates/my.cnf.j2
[client]
port        = 3306
socket      = /var/run/mysqld/mysqld.sock

[mysqld_safe]
socket      = /var/run/mysqld/mysqld.sock
nice        = 0

[mysqld]
user        = mysql
pid-file    = /var/run/mysqld/mysqld.pid
socket      = /var/run/mysqld/mysqld.sock
port        = 3306
basedir     = /usr
datadir     = /var/lib/mysql
tmpdir      = /tmp

lc-messages-dir             = /usr/share/mysql
skip-external-locking
bind-address                = 0.0.0.0
key_buffer                  = 16M
max_allowed_packet          = 16M
thread_stack                = 192K
thread_cache_size           = 8
myisam-recover              = BACKUP
query_cache_limit           = 1M
query_cache_size            = 16M
log_error                   = /var/log/mysql/error.log
log_bin                     = mysql-bin
binlog_do_db                = {{ mysql_user }}
expire_logs_days            = 10
max_binlog_size             = 100M
auto_increment_offset       = 1
auto_increment_increment    = 2
server_id                   = {{ sql_server_id }}

[mysqldump]
quick
quote-names
max_allowed_packet      = 16M

[mysql]
[isamchk]
key_buffer              = 16M

!includedir /etc/mysql/conf.d/
</code></pre>

<p>It is a default Ubuntu config file. The master master configuration consists out of the following:</p>

<pre><code>log_bin                     = mysql-bin
binlog_do_db                = {{ mysql_user }} # this database will be replicated
expire_logs_days            = 10
max_binlog_size             = 100M
auto_increment_offset       = 1
auto_increment_increment    = 2 # avoid primary key conflicts
server_id                   = {{ sql_server_id }} # variable set during ansible host creation
</code></pre>

<p>We also copy the debian mysql config file to <code>/root/.my.cnf</code>. Ansible needs this to connect to the database later on. Ansible has no way to copy a file on a host to another file on that host, so we need to fetch it first and copy it then to the new location. I use the hostname in the <code>dest</code> otherwise one server would receive the wrong credentials file.</p>

<pre><code>- fetch:
    src: /etc/mysql/debian.cnf 
    flat: yes
    dest: &quot;/tmp/my.cnf.{{ ansible_hostname }}&quot;

- copy:
    src: &quot;/tmp/my.cnf.{{ ansible_hostname }}&quot;
    dest: /root/.my.cnf
</code></pre>

<p>We create the MySQL database and user for that database on both nodes:</p>

<pre><code>- mysql_user: 
    name: &quot;{{ mysql_user }}&quot; 
    password: &quot;{{ mysql_password }}&quot;
    host: &quot;%&quot;
    priv: &#39;{{ mysql_user }}.*:ALL&#39;
    state: present 

- mysql_db: 
    name: &quot;{{ mysql_user }}&quot;
    state: present
</code></pre>

<p>I use the database username as the database name. This can be changed if needed.</p>

<p>The replication user is made on both nodes, with the correct permissions:</p>

<pre><code>- mysql_user: 
    name: &quot;replicator&quot; 
    host: &quot;%&quot; 
    password: &quot;{{ mysql_password }}&quot;
    priv: &quot;*.*:REPLICATION SLAVE&quot;
    state: present
  notify:
    - restart mysql
</code></pre>

<p>The following part has some Ansible Magic. The mysql_replication module only works once, it does not seem to be that much idempotent. If you run it again, it will fail and complain that the slave must be stopped first before it change its master. That is the expected behaviour, so we only want to set up the replication if that hasn&#39;t been done yet.</p>

<p>Therefore we first check for the existence of a file. If that file exists, the replication setup is skipped. If that file does not exist, we set up replication and then create that file. The file creation is done after the replication setup is done, so if the first one fails the latter one fails as well.</p>

<pre><code>- stat: path=/etc/mysql/ansible.repl
  register: check_sql_path
</code></pre>

<p>The existense of the file or folder can then later on be checked like so:</p>

<pre><code>when: check_sql_path.stat.exists == false # or true.
</code></pre>

<p>We also use a double <code>when</code> conditional. We need to set up the servers with each other&#39;s IP as the master. Therefore we need to run the setup for host A with the master IP of host B, and vice versa. </p>

<p>However, we also need to check for that file. Luckally Ansible supports <code>and</code> and <code>or</code> in their <code>when</code> conditionals. As you can see we extract the hostname of the other database node (<code>master_host: &quot;{{ groups.dbs[1] }}&quot;</code>), which in our case will be the IP address Openstack returns.</p>

<pre><code>- mysql_replication: 
    mode: changemaster 
    master_host: &quot;{{ groups.dbs[1] }}&quot; 
    master_user: replicator 
    master_password: &quot;{{ mysql_password }}&quot;
  when: check_sql_path.stat.exists == false and &#39;{{ inventory_hostname }}&#39; == &#39;{{ groups.dbs[0] }}&#39;
  notify:
    - restart mysql

- mysql_replication: 
    mode: changemaster 
    master_host: &quot;{{ groups.dbs[0] }}&quot; 
    master_user: replicator 
    master_password: &quot;{{ mysql_password }}&quot;
  when: check_sql_path.stat.exists == false and &#39;{{ inventory_hostname }}&#39; == &#39;{{ groups.dbs[1] }}&#39;
  notify:
    - restart mysql
</code></pre>

<p>After this has succeeded the files are created:</p>

<pre><code>- command: touch /etc/mysql/repl.ansible
  when: check_sql_path.stat.exists == false and &#39;{{ inventory_hostname }}&#39; == &#39;{{ groups.dbs[1] }}&#39;

- command: touch /etc/mysql/repl.ansible
  when: check_sql_path.stat.exists == false and &#39;{{ inventory_hostname }}&#39; == &#39;{{ groups.dbs[1] }}&#39;
</code></pre>

<p>We&#39;ve now got two servers running in master master replication mode. You can test this later on when the wordpress is set up by logging in to db server 1 and check the tables in the database. Then check the same on the second db server. </p>

<h4>Keepalived for MySQL</h4>

<p>The keepalive playbook is the same as the one we used in the load balancer setup. However, we check in which group the hostname is and based on that place a different config file:</p>

<pre><code># tasks/keepalived.yml
- template:
    src: keepalived.lbs.conf.j2
    dest: /etc/keepalived/keepalived.conf
  when: inventory_hostname in groups[&#39;lbs&#39;]
  notify:
    - restart keepalived

- template:
    src: keepalived.sql.conf.j2
    dest: /etc/keepalived/keepalived.conf
  when: inventory_hostname in groups[&#39;dbs&#39;]
  notify:
    - restart keepalived
</code></pre>

<p>During the creation of the host we also set a different priority for the database hosts, so that is handled as well.</p>

<p>The keepalived setup is again very simple. Move on the the last part, the actual application servers.</p>

<h3>App servers</h3>

<p><img src="https://raymii.org/s/inc/img/stupid-questions.png" /></p>

<p>The app servers are two Apache servers with PHP and GlusterFS for the file sync. </p>

<p>Glusterfs is set up first so that when we deploy the app the changes wil automagically arrive on the second node:</p>

<pre><code># tasks/main.yml
- name: Configure App Server
  hosts: app
  vars_files:
    - &quot;vars/main.yml&quot;
  user: root
  tasks:
    - include: tasks/configure-gluster-app.yml
    - include: tasks/configure-app.yml
  handlers:
    - include: handlers/main.yml
</code></pre>

<p>Because of <a href="https://bugs.launchpad.net/ubuntu/+source/glusterfs/+bug/1268064">a bug</a> in the Ubuntu Glusterfs packages we need to enable the official PPA and use newer glusterfs packages. Otherwise your OS will fail to boot, miserably. </p>

<p>Little rant here, this bug was in some form in 12.04, you would think that 3 years and loads of bug reports would have fixed in 14.04, but that is still not the case. It seems that if you want a stable distro you still need Red Hat... End rant.</p>

<pre><code># tasks/configure-gluster-app.yml
---
# boot bug in standard 14.04 packages: https://bugs.launchpad.net/ubuntu/+source/glusterfs/+bug/1268064
- apt_repository: 
    repo: &#39;ppa:semiosis/ubuntu-glusterfs-3.4&#39;
    state: present
    update_cache: yes
</code></pre>

<p>Our application servers are both glusterfs servers and clients of one another. You can set up a seperate glusterfs cluster, however that would be out of scope for this tutorial. If you expect lots of IO, it is a recommendation to do.</p>

<p>We install both the server and te client:</p>

<pre><code>- apt:
    name: &quot;{{ item }}&quot; 
    state: installed 
    update_cache: yes
  with_items:
    - glusterfs-server
    - glusterfs-client
    - ntp
</code></pre>

<p>Glusterfs has the concepts of volumes and bricks. A volume is served by the servers and mounted on the clients. A volume can consist out of multiple bricks, either providing striping or replication. In our case we go for replication, that means that both application servers have all the data.</p>

<p>I recommend you rad more on glusterfs, it is a really awesome product and I know of a few </p>

<p>We make sure the actual brick folder exists:</p>

<pre><code>- file: 
    path: &quot;{{ gluster_brick_dir }}&quot; 
    state: directory
</code></pre>

<p>There is no glusterfs module for Ansible, so here again we need to work around to prevent some idempotency issues. We make sure all the nodes know about each other:</p>

<pre><code>- shell: &quot;gluster peer probe {{ item }}&quot;
  with_items:
    - &quot;{{ groups.app }}&quot;
</code></pre>

<p>Then we get a list of all glusterfs nodes for use later on. Ansible gives me back a nice python-style list in the form of <code>u[10.1.1.2], u[10.1.1.3]</code> which is of no use in the later gluster commands, therefore we apply some sed replacements to filter and keep only the IP addresses:</p>

<pre><code>- shell: &#39;echo {{ groups.app }} | sed -e &quot;s/\]//g&quot; -e &quot;s/, u/, /g&quot; -e &quot;s/\[u//g&quot; -e &quot;s%,%:{{ gluster_brick_dir }} %g; s%$%:{{ gluster_brick_dir }}%&quot;&#39;
  register: gluster_bricks
  connection: local
</code></pre>

<p>We check if the volume already exists by issuing a <code>volume info</code> command. If that fails, the <code>||</code> will make sure the other action happens, that is create the volume. It is a replicated volume, with the data on at least two nodes. The output of the sed command from earlier is used to specify all the nodes. We also only do this on the first glusterfs server, it will otherwise fail on both or on the other.</p>

<pre><code>- shell: &#39;gluster volume info {{ gluster_volume }} || 
          gluster volume create {{ gluster_volume }} transport tcp replica 2
          {{ gluster_bricks.stdout }} force&#39;
  when: &#39;&quot;{{ inventory_hostname }}&quot; == &quot;{{ groups.app[0] }}&quot;&#39;
</code></pre>

<p>We wait a while to make sure the volume is actually being created. Without this delay the next steps would fail for me.</p>

<pre><code>- wait_for: 
    delay: 10
    timeout: 10
</code></pre>

<p>We check if the volume is already started, if not, we start it, on both nodes:</p>

<pre><code>- shell: &#39;gluster volume info {{ gluster_volume }} | grep &quot;Status: Started&quot; || 
          gluster volume start {{ gluster_volume }}&#39;
</code></pre>

<p>We make sure the <code>/var/www/html</code> folder exists, since this is the folder we will be mounting the glusterfs on:</p>

<pre><code>- file: 
    path: &quot;/var/www/html&quot; 
    state: directory
</code></pre>

<p>We mount the volume. The ansible module will also place this in <code>/etc/fstab</code> so we don&#39;t need to edit that as well:</p>

<ul>
<li>mount: 
  name: /var/www/html
  fstype: glusterfs 
  src: &quot;{{ groups.app[0] }}:{{ gluster_volume }}&quot;
  state: mounted</li>
</ul>

<p>If we now create a file on one node, for example <code>/var/www/html/test</code>, this file should appear on the other node as well. </p>

<p>Gluster cluster information can be found on either hosts with the <code>gluster volume info</code> or <code>gluster peer info</code> commands.</p>

<p>We can now deploy the actual application.</p>

<h4>Apache and Deployment</h4>

<p>We start by installing the Apache webserver, php (mod_php) and a few tools and modules:</p>

<pre><code># tasks/configure-app.yml
---
- apt:
    name=&quot;{{ item }}&quot; 
    state=latest 
    update_cache=yes
  with_items:
    - php5-mysql
    - python-pip
    - php5 
    - libapache2-mod-php5 
    - php5-mcrypt
    - vim
    - git
    - ntp
</code></pre>

<p>We are going to deploy wordpress right out of the git repository:</p>

<pre><code>- git: 
    repo: https://github.com/WordPress/WordPress.git 
    dest: /var/www/html/site
    force: yes
    update: no
  when: &#39;&quot;{{ inventory_hostname }}&quot; == &quot;{{ groups.app[0] }}&quot;&#39;
</code></pre>

<p>If you want to check out a specific version then give a branch name:</p>

<pre><code>version: 3.9-branch
</code></pre>

<p>We only do this on the first node since Gluster will take care of the sync to the other node.</p>

<p>We remove the default <code>index.html</code> file and replace it with our simple <code>index.php</code> that redirects to <code>/site</code> where wordpress is located:</p>

<pre><code>- file:
    dest: /var/www/html/index.html
    state: absent

- copy:
    src: index.php
    dest: /var/www/html/index.php
  when: &#39;&quot;{{ inventory_hostname }}&quot; == &quot;{{ groups.app[0] }}&quot;&#39; 
</code></pre>

<p>We deploy the <code>wp-config.php</code> file with our database settings pointing to the keepalived database IP:</p>

<pre><code>- template:
    src: wp-config.php.j2
    dest: /var/www/html/site/wp-config.php
  when: &#39;&quot;{{ inventory_hostname }}&quot; == &quot;{{ groups.app[0] }}&quot;&#39;
</code></pre>

<p><img src="https://raymii.org/s/inc/img/wordpress-install.png" /></p>

<p>You can now navigate to the floating IP address and start the wordpress installation. </p>

<h3>Testing the cluster</h3>

<p>When it is all up and running and you have successfully deployed your application you of course want to know if the cluster setup works or not. How to do that best other that just shutting down all nodes in one availability zone? Or just the database servers or the load balancers? Try it out, start them up again, see that it all still works.</p>

<p>Congratulations, you&#39;ve now got an awesome cluster setup running, all deployed via Ansible and Openstack!</p>

<p><img src="https://raymii.org/s/inc/img/youre-awesome.png" /></p>

<p><a href="https://github.com/RaymiiOrg/ansible/tree/master/openstack-example">Repository</a>.</p>

<h3>What if shit hits the fan?</h3>

<p><img src="https://raymii.org/s/inc/img/shtf.png" /></p>

<p>You now have your awesome cluster setup and working. As you know, this cluster setup protects against full host failure per layer, thus providing protection against one full availability zone being offline.</p>

<p>In the case that happens, your site will still be working. However, what do do when the Availability Zone issue is fixed?</p>

<p>Make sure your servers in the affected zone are offline. </p>

<p>Start with the load balancer, turn it on and check the logs to see if it picks up keepalived. If it had the highest priority it should pick up the VIP again. If it had a lower priority, try stopping keepalived on the master and see if it fails over. If so, make sure the nginx config still works and you are good to go.</p>

<p>Start up the application server. Make sure it starts correctly. Wait a while for GlusterFS to sync the files over. Test the sync by creating a few files on one node and check the other node if they are there as well. Then stop the webserver on the node that kept working during the crash and test the website. If that all works you are good to go.</p>

<p>The database is a trickier part. If it has diverged too much, as in, it has been offline to long you will need to fix the mysql replication. Stop the slave on both nodes. Also stop the master. Create a dump of the database srever that kept working and import it on the other db server. Check the binlog positions and start up replication manually again with the correct file and position. </p>
<hr>Tags: <a href="../tags/ansible.html" class="link">ansible, </a><a href="../tags/cloud.html" class="link">cloud, </a><a href="../tags/compute.html" class="link">compute, </a><a href="../tags/dashboard.html" class="link">dashboard, </a><a href="../tags/glusterfs.html" class="link">glusterfs, </a><a href="../tags/ha.html" class="link">ha, </a><a href="../tags/keepalived.html" class="link">keepalived, </a><a href="../tags/mysql.html" class="link">mysql, </a><a href="../tags/openstack.html" class="link">openstack, </a><a href="../tags/python.html" class="link">python, </a><a href="../tags/ubuntu.html" class="link">ubuntu, </a><a href="../tags/wordpress.html" class="link">wordpress, </a><div class="footer">
                <hr>
                <p>Generated by <a href="/s/software/ingsoc.html">ingsoc</a> | 
                <a href="/s/software/Sparkling_Network.html">Cluster Status</a> | 
                <a href="/s/static/About.html">About</a><br />
                </div>
            </div>
        </div>
    </div>  
    </div>
    </div>
     
    <!-- Piwik --> 
    <script type="text/javascript">
    var pkBaseURL = (("https:" == document.location.protocol) ? "https://hosted-oswa.org/piwik/" : "http://hosted-oswa.org/piwik/");
    document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
    </script><script type="text/javascript">
    try {
    var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 1);
    piwikTracker.trackPageView();
    piwikTracker.enableLinkTracking();
    } catch( err ) {}
    </script><noscript><p><img src="http://hosted-oswa.org/piwik/piwik.php?idsite=1" style="border:0" alt="" /></p></noscript>
    <!-- End Piwik Tracking Code -->
    </body>
    </html>
    