<!-- nominify -->



    <!DOCTYPE html>
    <html lang="en">
        <head>
        <title>Decrypt/Extract NitroKey HSM/SmartCard-HSM RSA private keys - Raymii.org</title>
        <link href="/s/inc/css/custom-first.css" rel="stylesheet" />
        <link href="/s/inc/css/light.css" rel="stylesheet"  />
        <link href="/s/inc/css/custom.css" rel="stylesheet" title="custom" />
        <script src="/s//inc/js/toc.js" type="text/javascript"></script>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
        <link href="inc/img/icons/iphone.png" rel="apple-touch-icon" />
        <link href="inc/img/icons/ipad.png" rel="apple-touch-icon" sizes="76x76" />
        <link href="inc/img/icons/iphone-retina.png" rel="apple-touch-icon" sizes="120x120" />
        <link href="inc/img/icons/ipad-retina.png" rel="apple-touch-icon" sizes="152x152" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link type="application/opensearchdescription+xml" rel="search" href="/s/inc/opensearch.xml"/>
        <link rel="alternate" type="application/rss+xml" title="RSS Feed for Raymii.org" href="https://raymii.org/s/feed.xml" />
    </head>
    <body>
        <a id="top-of-page"></a>
        <div class="container-fluid ">
            <div class="row">
                <div class="col-md-12">
                    <div class="col-md-3 col-sm-3 max-200">
                        <div class="well well-none"> 
                            <h3 class="headheader"><a href="https://raymii.org/s/">Raymii.org <img src="/s/inc/img/resistor-50.png" alt="IEC Resistor logo"></a></h3>
                            <h6 class="headheader">Quis custodiet ipsos custodes?</h6>
                            <h6><a href="https://raymii.org/s/feed.xml">RSS Feed</a></h6>
                        </div>
          

    
    <form role="search" action="https://encrypted.google.com/search">
        <div class="form-group">
          <input type="hidden" name="as_sitesearch" value="raymii.org">
          <input type="hidden" name="as_qdr" value="all">
          <input type="text" name="as_q" class="form-control" placeholder="Search">
        </div>
      </form>
      <div class="menu"><ul class="nav nav-pills nav-stacked"><li><a href="/s/index.html" class="special-menu">Home</a></li><li class='bottom-spacing'><a href="/s/everything.html" class="special-menu">All Pages</a></li><li class='hideifsmall'><a href="/s/tags/bash.html" class="link">Bash</a></li><li class='hideifsmall'><a href="/s/tags/monitoring.html" class="link">Monitoring</a></li><li class='hideifsmall'><a href="/s/tags/ssl.html" class="link">SSL</a></li><li class='hideifsmall'><a href="/s/tags/debian.html" class="link">Debian</a></li><li class='hideifsmall'><a href="/s/tags/python.html" class="link">Python</a></li><li class='hideifsmall'><a href="/s/tags/vpn.html" class="link">VPN</a></li><li class='hideifsmall'><a href="/s/tags/ubuntu.html" class="link">Ubuntu</a></li><li class='hideifsmall'><a href="/s/tags/nginx.html" class="link">nginx</a></li><li class='hideifsmall'><a href="/s/tags/openstack.html" class="link">Openstack</a></li><li class='hideifsmall'><a href="/s/tags/ansible.html" class="link">Ansible</a></li></ul>            
               <!-- advertisement start -->
                <a href="http://clients.inceptionhosting.com/aff.php?aff=083">Inception Hosting Affiliate Link</a><br />
                <a href="https://www.digitalocean.com/?refcode=7435ae6b8212">Digital Ocean Affiliate Link, $10 free credit.</a><br />
                <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                <!-- Raymii-2 -->
                <ins class="adsbygoogle"
                     style="display:inline-block;width:200px;height:200px"
                     data-ad-client="ca-pub-7993642564731324"
                     data-ad-slot="9322003332"></ins>
                <script>
                (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
                <!-- advertisement end -->
                </div>
           </div>  
           <div class="col-md-8 col-sm-8"> 
                <div class="inner">

           <h2 class='headheader'>Decrypt/Extract NitroKey HSM/SmartCard-HSM RSA private keys</h2><ul class="breadcrumb"><li><a href="../index.html" class="link">Home</a></li><li><a href="../articles/index.html" class="link">Articles</a></li><li><a href="Decrypt_NitroKey_HSM_or_SmartCard-HSM_private_keys.html" class="link">Decrypt/Extract NitroKey HSM/SmartCard-HSM RSA private keys</a></li></ul><p><small>10-07-2016</small> | <small>Remy van Elst</small></p><div class='ad'>
                            <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
                            <!-- voorartikel -->
                            <ins class="adsbygoogle"
                                 style="display:inline-block;width:728px;height:90px"
                                 data-ad-client="ca-pub-7993642564731324"
                                 data-ad-slot="6172324376"></ins>
                            <script>
                            (adsbygoogle = window.adsbygoogle || []).push({});
                            </script>
                        </div><br><div id="toc"><h3>Table of Contents</h3></div><hr><div id="contents"><p>This is a guide which shows you how to extract private RSA key material from the NitroKey HSM / SmartCard-HSM using the DKEK. This way you can get the private key out of the HSM in an unencrypted form. It does require access to the HSM device, all the DKEK share and their passwords. Do note that doing this defeats the entire purpose of a HSM, namely that you never have access to the keys. In the article I&#39;ll go over some explanation why this might be a feature you need and why it might be a case of security over convinience.</p>

<h3>Recap of a HSM</h3>

<p><img src="https://raymii.org/s/inc/img/nitrokey1.jpg" width="500" height="600"></p>

<blockquote>
<p>The NitroKey HSM in a sealed package</p>
</blockquote>

<p>A Hardware Security Module, HSM, is a device where secure key material is stored. This private data only be accessed by the HSM, it can never leave the device. Most HSM devices are also tamper-resistant. This means that when opened, moved or otherwise (software) tampered with, they wipe the key material. HSM&#39;s come in a variety of formfactors, ranging from SmartCards and small USB devices, to full size PCI cards and even 19&quot; rackmountable server-like devices. The difference between all those devices is speed and storage capacity. Most commercial HSM&#39;s are certified to the <a href="https://en.wikipedia.org/wiki/FIPS_140-2">FIPS-140-2</a>  standard.</p>

<p>I have multiple <a href="https://raymii.org/s/articles/Get_Started_With_The_Nitrokey_HSM.html">articles on</a> the <a href="https://raymii.org/s/articles/Nitrokey_HSM_in_Apache_with_mod_nss.html">NitroKey HSM/SmartCard-HSM</a>. I also have a lot of professional experience with large expensive HSM hardware. </p>

<p>If you want to know more on the NitroKey HSM then please read the <a href="https://raymii.org/s/articles/Get_Started_With_The_Nitrokey_HSM.html">getting started articles</a>. </p>

<p>The main purpose of the HSM is to protect key material. It allows you to make sure that the private key material can never be stolen or compromised. It does allow you to wrap a key for export/transport to another HSM, for example, to create redundancy or backup. We use this mechanism to decrypt the keys outside of the HSM.</p>

<p>At the end of the article you can read the rationale, where I hope to explain why this is both a security issue as well as how to mitigate it.</p>

<p>In this article I&#39;ll use the terms HSM, NitroKey HSM and SmartCard-HSM, but when I do I mean the same device. </p>

<p>The <a href="http://nitrokey.com">Nitrokey HSM</a> is an open hardware and open software device. It is a USB version of the <a href="http://www.smartcard-hsm.com/">SmartCard-HSM</a>. Both the <a href="http://www.smartcard-hsm.com/opensource.html">SmartCard-HSM</a> as the <a href="https://github.com/nitrokey">Nitrokey HSM</a> have sources available and are fully supported by the <a href="https://github.com/OpenSC/OpenSC/wiki/SmartCardHSM">OpenSC</a> project.</p>

<p>The NitroKey is as far as I know one of the few fully open source devices. All the big HSM&#39;s I&#39;ve used were either under NDA or completely closed source. In my opinion a device like this can only be secure when they are open source. The device supports up to 60 ECC GF(p) 256-bit keys and up to 48 RSA 2048-bit keys. </p>

<h3>Access to the CardContact SDK</h3>

<p>The process requires access to the CardContact SDK. This is a collection of software you can use in your own projects (SDK, software development kit). It also includes examples to use the HSM, like a key manager or a .p12 importer.</p>

<p>To get access to the SDK you need a SmartCardHSM/NitroKey HSM. You need to generate a keypair in the device that will be used for accessing the content network and git repositories.</p>

<p>Access to the SDK does not cost money, but it does require you to have a HSM device. </p>

<p>Read <a href="http://www.cardcontact.de/cdn/about.html">this page</a> to find out more about the CDN. First <a href="http://www.cardcontact.de/cdn/activation.html">create and activate your developer account</a> and then <a href="http://www.cardcontact.de/cdn/gitaccess.html">clone all the repositories</a>.</p>

<p>You will need the <a href="http://www.openscdp.org/scsh3/index.html">SmartCard Shell v3</a> which you can download <a href="http://www.openscdp.org/scsh3/index.html">here</a>. </p>

<p>You will also need the <a href="http://www.openscdp.org/scripts/index.html">SmartCard Script collection</a>. If you have registered a developer account you will already have the scripts and smartcard shell.</p>

<p>Do note that this is a Java tool, so make sure you have Java installed as well.</p>

<p>Here is a screenshot of the SCSH (shell) running the key decryption:</p>

<p><img src="https://raymii.org/s/inc/img/hsm_scsh.png"></p>

<p>The primes <code>p</code> and <code>q</code> are used to derive the private exponent <code>d</code> with the public exponent <code>e</code>. I&#39;ll show some simple python code later on to construct the private key in a usable format.</p>

<h3>DKEK (Device Key Encryption Key)</h3>

<p>The DKEK, device key encryption key, is used when initializing the HSM. Initializing a HSM means that you remove all the keys and other data stored in it, basically formatting it. Simply said, the DKEK encrypts the keys on the device and the keys you export out of the device (wrap).</p>

<p>The NitroKey HSM generates a DKEK when the device is initialized, but is also allows you go generate one or more DKEK&#39;s beforehand and import those in the device during the initialization process. You can have multiple DKEK&#39;s, spread over multiple persons. A DKEK can even have multiple passwords (using <a href="https://www.nitrokey.com/ru/news/2015/new-nitrokey-hsm-supports-n-m-threshold-scheme-and-sophisticated-key-management">an n-of-m</a> threshold scheme.)</p>

<p>If you use the device in production you will (hopefully) have selected strong user and SO PIN&#39;s, as well as have multiple DKEK shares with strong passwords on them. </p>

<p>You can import the DKEK in another HSM device and then restore backups of the exported keys to this new device. As said, this way you can have a backup or redundancy of the HSM device.  To find out how to do that please read the <a href="https://raymii.org/s/articles/Get_Started_With_The_Nitrokey_HSM.html">getting started article</a>.  </p>

<p>We will use this DKEK to decrypt the secret key material on the HSM. Since it&#39;s open source, we can look at how the DKEK is made, how the DKEK wraps the keys and reverse that process. Do note that we still need all the DKEK shares, their passwords and access to the HSM device. </p>

<h3>Decrypting a key with the example</h3>

<p><strong>THIS WILL REINITIALIZE YOU HSM</strong></p>

<p>Make sure to backup important keys on your HSM first! (Test them as well).</p>

<p>I&#39;ll first talk about the example included to decrypt a key. This example initializes the HSM with two DKEK shares, then generates a key and dumps those parameters. </p>

<p>The example states that it requires an NDA. I contacted the main developer and got permission to publish, see the screenshot below. (Thank you for that Andreas).</p>

<p><img src="https://raymii.org/s/inc/img/hsm_nda.png"></p>

<p>Fire up the SmartCard Shell and set up the workspace as the CDN documentation describes. Use the File menu -&gt; Run Script and load the <code>sc-hsm-workspace/sc-hsm-sdk-scripts/key_import/decrypt_keyblob.js</code> script. </p>

<p><strong>THIS WILL REINITIALIZE YOU HSM</strong></p>

<p>This is the <code>decrypt_keyblob.js</code> script:</p>

<pre><code>/*
 * Decrypt Key Blob from SmartCard-HSM
 *
 * (c) 2014 CardContact Software &amp; System Consulting, Andreas Schwier, Minden, Germany
 *
 * Information contained in this script is confidential and released under NDA
 *
 * This script initializes a SmartCard-HSM with two DKEK shares, generates and exports a RSA key
 * From the DKEK share it generates the Kenc/Mmac for key wrap and decodes the exported key blob
 *
 * Please note, that the sc-hsm-tool will further wrap the key blob generated by the SmartCard-HSM
 * with the private key description and the certificate read from an EF in the device. Please see
 * the sc-hsm-tool.c source for details.
 *
 * Warning: The device will be re-initialized by this script.
 */

PublicKeyReference = require(&#39;scsh/eac/PublicKeyReference&#39;).PublicKeyReference;
SmartCardHSM = require(&quot;scsh/sc-hsm/SmartCardHSM&quot;).SmartCardHSM;
DKEK = require(&quot;scsh/sc-hsm/DKEK&quot;).DKEK;

var pin = new ByteString(&quot;648219&quot;, ASCII);
var initializationCode = new ByteString(&quot;57621880&quot;, ASCII);

var dkekshare1 = new ByteString(&quot;A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5&quot;, HEX);
var dkekshare2 = new ByteString(&quot;E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1&quot;, HEX);

// Attach to SmartCard-HSM

var card = new Card(_scsh3.reader);
var sc = new SmartCardHSM(card);

if (sc.queryUserPINStatus() == 0x6984) {
  var page = &quot;&lt;html&gt;&lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;&quot; +
       &quot;&lt;p&gt;This is a new device that has never been initialized before.&lt;/p&gt;&lt;br/&gt;&quot; +
       &quot;&lt;p&gt;If you choose to continue this test, then the device initialization code will be set to &quot; + initializationCode.toString(ASCII) + &quot; &lt;/p&gt;&lt;br/&gt;&quot; +
       &quot;&lt;p&gt;Please be advised, that this code can be changed later, however the same code must be used in subsequent re-initialization of the device.&lt;/p&gt;&lt;br/&gt;&quot; +
       &quot;&lt;p&gt;Press OK to continue or Cancel to abort.&lt;/p&gt;&quot; +
       &quot;&lt;/html&gt;&quot;;
  var userAction = Dialog.prompt(page);
  assert(userAction != null);
}


// Initialize Device with a double DKEK share

sc.initDevice(new ByteString(&quot;0001&quot;, HEX), pin, initializationCode, 3, 2);

sc.importKeyShare(dkekshare1);
var status = sc.importKeyShare(dkekshare2);

print(&quot;Device initialized:&quot;);
print(&quot;-------------------&quot;);
print(&quot;SW          : &quot; + status.sw.toString(HEX));
print(&quot;Shares      : &quot; + status.shares);
print(&quot;Outstanding : &quot; + status.outstanding); 
print(&quot;KVC         : &quot; + status.kcv.toString(HEX));
print(&quot;&quot;);


// Determine keys for wrap/unwrap

var crypto = new Crypto();

var dkek = new DKEK(crypto);
dkek.importDKEKShare(dkekshare1);
dkek.importDKEKShare(dkekshare2);
var kenc = dkek.getKENC();
var kmac = dkek.getKMAC();

print(&quot;Values derived from DKEK shared:&quot;);
print(&quot;--------------------------------&quot;);
print(&quot;DKEK        : &quot; + dkek.dkek.toString(HEX));
print(&quot;KVC         : &quot; + dkek.getKCV().toString(HEX));
print(&quot;Kenc        : &quot; + kenc.getComponent(Key.AES).toString(HEX));
print(&quot;Kmac        : &quot; + kmac.getComponent(Key.AES).toString(HEX));
print(&quot;&quot;);


// Generate a Test RSA Key with 1024 Bit

sc.verifyUserPIN(pin);

var chr = new PublicKeyReference(&quot;UT&quot;, &quot;TESTKEY01&quot;, &quot;00000&quot;);
var innerCAR = new PublicKeyReference(&quot;DECA00001&quot; + &quot;00001&quot;);
var algo = new ByteString(&quot;id-TA-RSA-v1-5-SHA-256&quot;, OID);

var keydata = SmartCardHSM.buildGAKPwithRSA(innerCAR, algo, chr, 1024);
// SmartCardHSM.dumpKeyData(keydata);

var rsp = this.sc.generateAsymmetricKeyPair(1, 0, keydata);
// print(&quot;Card generated certificate signing request&quot;);
// print(new ASN1(rsp));


// Wrap key

var keyblob = sc.wrapKey(1);

print(&quot;Key blob&quot;);
print(&quot;--------&quot;);
print(keyblob);

dkek.dumpKeyBLOB(keyblob);
</code></pre>

<p>This is example output:</p>

<pre><code>&gt;load(&quot;/home/remy/git/sc-hsm-workspace/sc-hsm-sdk-scripts/key_import/decrypt_keyblob.js&quot;);
Device initialized:
-------------------
SW          : 9000
Shares      : 2
Outstanding : 0
KVC         : BB391415C05E39D7

Values derived from DKEK shared:
--------------------------------
DKEK        : 4444444444444444444444444444444444444444444444444444444444444444
KVC         : BB391415C05E39D7
Kenc        : 34423C9AB36899BD772D73DA3E350709F009634946C288A7B5E8A248868AE9FF
Kmac        : 1392790984A79DA93E797C0FD1919E16C9FE90D652A147DF16186E6840E9F2EB

Key blob
--------
0000  BB 39 14 15 C0 5E 39 D7 06 00 0A 04 00 7F 00 07  .9...^9.........
[...]
0200  89 41 86 5F 7A 07 EA 6C F2 72 53                 .A._z..l.rS

Values from key blob:
---------------------
Checking the MAC      : Passed
KCV                   : BB391415C05E39D7    [Must match the KCV of the DKEK for import]
Key type              : 6    [6=RSA, 12=ECC]
Default Algorithm ID  : 0.4.0.127.0.7.2.2.2.1.2 (10)     [Matches algo in buildGAKPwithRSA()]
Allowed Algorithm IDs :  (0)    [Not used]
Access Conditions     :  (0)    [Not used]
Key OID               :  (0)    [Not used]
0000  81 BD 22 DC 7A 59 9E AD 04 00 00 40 E6 11 4D E4  ..&quot;.zY.....@..M.
[...]
01D0  06 37 89 6A 04 A9 00 03 01 00 01 80 00 00 00 00  .7.j............

Randomize             : 81BD22DC7A599EAD    [Random data prepended at export]
Key size              : 1024    [Key size in bits]
DP1 = d mod (p - 1)   : E6114DE413BB84118673B60947D04D1B95C8BA489467F86A050D3CEDC8654C2C7ED1A1340D1B87234B3C99AA434833025CA306FF3DEE36EDBDC6089CA10BF431 (64)
DQ1 = d mod (q - 1)   : ACCD4794CC41372263B859C1B9448C91E3082B9C96CBF6A19BFB8AB495B7EF83C29F87B58F79661D68395F0978CCFD91E0AE823594DF33043269270994CD45F9 (64)
Prime factor p        : FD6D83D3ABBB6527AA612008CD8B1F57579FAFA9DE8B30DAA4051A617043D4FAC7D94F29672990F2B04FBE59F79C8BCCFBFEEA038844858AB55A97D089DD531F (64)
PQ = q - 1 mod p      : BFE203FE566E0CCED58565C26B30D68D984EE42DC9B766C7598E264E6E558D41B24E72D04D96C394F4FF10728DF2895975A6BD5E605C75271DE28BEE6CED3548 (64)
Prime factor q        : D604513568BD59C9E83FECC653FA1168A198275859D4FD1ADA62EB0B0354B9FC2DC33F70727A5DE328890B103C2CED16931C84C5439436471F968AAF7F4EB737 (64)
Modulus               : D3DDD24D86EF89F0DA9EE2933517A1117AB0C9B75ACAF261B8699A8F8A76351468B641C9F51071EAA7C681E975D9AF7BB8F6E3B1BB234DD4A6A65B4E089A94BB7441F6FD8210D4B5CA0275B64921F081181AD3CD137B2EB9BEE9545B2919617B89C4A4634205342A1A989BB0491C0A20682646D2DCE7699371300637896A04A9 (128)
Exponent              : 010001 (3)
&gt;
</code></pre>

<p>You now have a re-initialized HSM and all the data you need to reconstruct the private key. We will continue this article with adapting the script to decrypt an existing key (and not hose the HSM). Then we will use some simple Python code to transform those values we got (<code>p</code>, <code>q</code> etc) into a usable RSA keypair.</p>

<h3>Reconstruct a DKEK and decrypt an existing key</h3>

<p>The above script reinitializes your HSM, which might not be what you want if you want to export an existing key. In the code it has two DKEK shares set:</p>

<pre><code>var dkekshare1 = new ByteString(&quot;A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5&quot;, HEX);
var dkekshare2 = new ByteString(&quot;E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1&quot;, HEX);
</code></pre>

<p>The device is initialized and then the shares are loaded in the device:</p>

<pre><code>sc.initDevice(new ByteString(&quot;0001&quot;, HEX), pin, initializationCode, 3, 2);

sc.importKeyShare(dkekshare1);
var status = sc.importKeyShare(dkekshare2);
</code></pre>

<p>We can load our own DKEK in by converting it to a HEX string. It took me quite some time to figure out how to do that. I decided to look into how the DKEK is generated and reverse that. </p>

<h4>DKEK decryption</h4>

<p>I basically adapted the <code>load_dkek_in_device</code> function and stripped out the actual loading the DKEK in the device. Instead, I added a simple function that prints the <code>u8</code> char as HEX in the format that the <code>decrypt_keyblob.js</code> understands. </p>

<pre><code>printf(&quot;DKEK Share HEX: \n\n&quot;);

  for (i = 0; i &lt; sizeof(dkekinfo.dkek_share); i++)
  {
      printf(&quot;%02X&quot;, dkekinfo.dkek_share[i]);
  }
  printf(&quot;\n\n&quot;);
</code></pre>

<p>The rest of the function is almost the same, including the password entry and decryption part. </p>

<p>See my fork <a href="https://github.com/RaymiiOrg/OpenSC/tree/dkek_share_print">for the code</a>. I&#39;ve included the code at the end of this article, if for whatever reason the pull request isn&#39;t accepted. </p>

<p>To build it, clone the repo:</p>

<pre><code>https://github.com/RaymiiOrg/OpenSC.git
</code></pre>

<p>Switch to the branch:</p>

<pre><code>cd OpenSC
git checkout dkek_share_print
</code></pre>

<p>Bootstrap:</p>

<pre><code>bash ./bootstrap
</code></pre>

<p>Build the tools:</p>

<pre><code>make all tools
</code></pre>

<p>Now you have a binary in the <code>src/tools/</code> folder named <code>sc-hsm-tool</code>.</p>

<p>Use this to deconstruct the DKEK. You of course need to have loaded a DKEK when you initialized your HSM.  To find out how to do that please read the <a href="https://raymii.org/s/articles/Get_Started_With_The_Nitrokey_HSM.html">getting started article</a>.  </p>

<pre><code>$ ./src/tools/sc-hsm-tool --print-dkek-share ./dkek-share-1.pbe 
</code></pre>

<p>Example Output:</p>

<pre><code>Using reader with a card: Nitrokey Nitrokey HSM (010000000000000000000000) 00 00
Enter password to decrypt DKEK share : 

Deciphering DKEK share, please wait...
DKEK Share HEX: 

20B3EE1CABA5ECA7ECEB6BE51F11BD9A04F5FE9A6B0A1E0A8BC13074D32CF830
</code></pre>

<p>If you have multiple DKEK shares you need to decrypt all of them.</p>

<p><strong>Do note that this is the unencrypted DKEK share. Never share it.</strong></p>

<h4>Decrypting an existing key</h4>

<p>Now we have the DKEK we can change the script to use this DKEK. We also remove all the initializing code and change the KEY REF in the <code>wrapkey()</code> function to the correct key we want to export (find with: <code>pkcs15-tool -D</code>).</p>

<p>This is the script, <code>decrypt_keyblob_2.js</code>:</p>

<pre><code>PublicKeyReference = require(&#39;scsh/eac/PublicKeyReference&#39;).PublicKeyReference;
SmartCardHSM = require(&quot;scsh/sc-hsm/SmartCardHSM&quot;).SmartCardHSM;
DKEK = require(&quot;scsh/sc-hsm/DKEK&quot;).DKEK;

var pin = new ByteString(&quot;648219&quot;, ASCII);
var initializationCode = new ByteString(&quot;57621880&quot;, ASCII);

//var dkekshare1 = new ByteString(&quot;A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5A5&quot;, HEX);
//var dkekshare2 = new ByteString(&quot;E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1E1&quot;, HEX);
var dkekshare2 = new ByteString(&quot;20B3EE1CABA5ECA7ECEB6BE51F11BD9A04F5FE9A6B0A1E0A8BC13074D32CF830&quot;, HEX);

// Attach to SmartCard-HSM

var card = new Card(_scsh3.reader);
var sc = new SmartCardHSM(card);

if (sc.queryUserPINStatus() == 0x6984) {
  var page = &quot;&lt;html&gt;&lt;p&gt;&lt;b&gt;Warning:&lt;/b&gt;&lt;/p&gt;&lt;br/&gt;&quot; +
       &quot;&lt;p&gt;This is a new device that has never been initialized before.&lt;/p&gt;&lt;br/&gt;&quot; +
       &quot;&lt;p&gt;If you choose to continue this test, then the device initialization code will be set to &quot; + initializationCode.toString(ASCII) + &quot; &lt;/p&gt;&lt;br/&gt;&quot; +
       &quot;&lt;p&gt;Please be advised, that this code can be changed later, however the same code must be used in subsequent re-initialization of the device.&lt;/p&gt;&lt;br/&gt;&quot; +
       &quot;&lt;p&gt;Press OK to continue or Cancel to abort.&lt;/p&gt;&quot; +
       &quot;&lt;/html&gt;&quot;;
  var userAction = Dialog.prompt(page);
  assert(userAction != null);
}

// Determine keys for wrap/unwrap

var crypto = new Crypto();

var dkek = new DKEK(crypto);
//dkek.importDKEKShare(dkekshare1);
dkek.importDKEKShare(dkekshare2);
var kenc = dkek.getKENC();
var kmac = dkek.getKMAC();

print(&quot;Values derived from DKEK shared:&quot;);
print(&quot;--------------------------------&quot;);
print(&quot;DKEK        : &quot; + dkek.dkek.toString(HEX));
print(&quot;KVC         : &quot; + dkek.getKCV().toString(HEX));
print(&quot;Kenc        : &quot; + kenc.getComponent(Key.AES).toString(HEX));
print(&quot;Kmac        : &quot; + kmac.getComponent(Key.AES).toString(HEX));
print(&quot;&quot;);

// Generate a Test RSA Key with 1024 Bit

sc.verifyUserPIN(pin);

// Wrap key (KEY REF 1)

var keyblob = sc.wrapKey(1);

print(&quot;Key blob&quot;);
print(&quot;--------&quot;);
print(keyblob);

dkek.dumpKeyBLOB(keyblob);
</code></pre>

<p>This script will not reinitialize the HSM, it will use the existing DKEK we&#39;ve calculated. Read on to see the full procedure.</p>

<h4>Testing with an existing key</h4>

<p>We will initialize the HSM with one DKEK and create a keypair. This keypair is used to encrypt a small file with OpenSSL. Then we retreive the private key to a file and use OpenSSL to decrypt the earlier encrypted file with the exported key.</p>

<p>Generate a DKEK, example password 123456789:</p>

<pre><code>sc-hsm-tool --create-dkek-share dkek-share-1.pbe
</code></pre>

<p>Output:</p>

<pre><code>Using reader with a card: Nitrokey Nitrokey HSM (010000000000000000000000) 00 00

The DKEK share will be enciphered using a key derived from a user supplied password.
The security of the DKEK share relies on a well chosen and sufficiently long password.
The recommended length is more than 10 characters, which are mixed letters, numbers and
symbols.

Please keep the generated DKEK share file in a safe location. We also recommend to keep a
paper printout, in case the electronic version becomes unavailable. A printable version
of the file can be generated using &quot;openssl base64 -in &lt;filename&gt;&quot;.
Enter password to encrypt DKEK share : &lt;123456789&gt;

Please retype password to confirm : &lt;123456789&gt;

Enciphering DKEK share, please wait...
DKEK share created and saved to dkek-share-1.pbe
</code></pre>

<p>(Re)initialize the HSM:</p>

<p><strong>THIS WILL REINITIALIZE YOU HSM</strong></p>

<p>Make sure to backup important keys on your HSM first! (Test them as well).</p>

<pre><code>sc-hsm-tool --initialize --so-pin 3537363231383830 --pin 648219 --dkek-shares 1
</code></pre>

<p>Output:</p>

<pre><code>Using reader with a card: Nitrokey Nitrokey HSM (010000000000000000000000) 00 00
</code></pre>

<p>The HSM is now waiting for the DKEK share:</p>

<pre><code>$ sc-hsm-tool 
</code></pre>

<p>Output:</p>

<pre><code>Using reader with a card: Nitrokey Nitrokey HSM (010000000000000000000000) 00 00
Version              : 2.0
Config options       :
  User PIN reset with SO-PIN enabled
SO-PIN tries left    : 15
User PIN tries left  : 3
DKEK shares          : 1
DKEK import pending, 1 share(s) still missing
</code></pre>

<p>Load the DKEK share:</p>

<pre><code>sc-hsm-tool --import-dkek-share dkek-share-1.pbe
</code></pre>

<p>Output:</p>

<pre><code>Using reader with a card: Nitrokey Nitrokey HSM (010000000000000000000000) 00 00
Enter password to decrypt DKEK share : 

Deciphering DKEK share, please wait...
DKEK share imported
DKEK shares          : 1
DKEK key check value : 0FB85F69F6EBF256
</code></pre>

<p>The DKEK is now loaded:</p>

<pre><code>sc-hsm-tool 
</code></pre>

<p>Output:</p>

<pre><code>Using reader with a card: Nitrokey Nitrokey HSM (010000000000000000000000) 00 00
Version              : 2.0
Config options       :
  User PIN reset with SO-PIN enabled
SO-PIN tries left    : 15
User PIN tries left  : 3
DKEK shares          : 1
DKEK key check value : 0FB85F69F6EBF256
</code></pre>

<p>Generate a keypair in slot 2:</p>

<pre><code>$ pkcs11-tool --module opensc-pkcs11.so --login --pin 648219 --keypairgen --key-type rsa:1024 --id 2 --label &quot;HSM RSA Key Remy&quot;
</code></pre>

<p>Output:</p>

<pre><code>Using slot 0 with a present token (0x0)
Key pair generated:
Private Key Object; RSA 
  label:      HSM RSA Key Remy
  ID:         02
  Usage:      decrypt, sign, unwrap
Public Key Object; RSA 1024 bits
  label:      HSM RSA Key Remy
  ID:         02
  Usage:      encrypt, verify, wrap
</code></pre>

<p>You can, if you want, also import a wrapped key. See the getting started guide to find out how to do that.</p>

<p>Find the correct keyref:</p>

<pre><code>pkcs15-tool -D
</code></pre>

<p>Output:</p>

<pre><code>Private RSA Key [HSM RSA Key Remy]
  Object Flags   : [0x3], private, modifiable
  Usage          : [0x2E], decrypt, sign, signRecover, unwrap
  Access Flags   : [0x1D], sensitive, alwaysSensitive, neverExtract, local
  ModLength      : 1024
  Key ref        : 1 (0x1)
  Native         : yes
  Auth ID        : 01
  ID             : 02
  MD:guid        : 557bcb43-47a3-d83f-f863-ccb6b8432192
</code></pre>

<p>The keyref is <code>1</code> in this case.</p>

<p>Get the public key from the HSM:</p>

<pre><code>pkcs15-tool --read-public-key 2
</code></pre>

<p>Output:</p>

<pre><code>Using reader with a card: Nitrokey Nitrokey HSM (010000000000000000000000) 00 00
-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC9DEoPbDQTZczSTOZsj83ZqJai
+3ZVqD5fFILqE92w3zlcG+0qntLhwxCnYQIRv0reAJIQT5EN4WC0RP+vH2j43onM
+o2oVxCPqlckc4wQ0SD3h3ncbFO40zSKLGr9kJd7IIxyvces6ZtVdcxO49Ucv74B
x4D/jWFARAirngU6LQIDAQAB
-----END PUBLIC KEY-----
</code></pre>

<p>Save it to a file, <code>hsm.pub</code>.</p>

<p>Please read the <a href="https://raymii.org/s/articles/Get_Started_With_The_Nitrokey_HSM.html">getting started article</a> to see what to put in the <code>openssl</code> <code>hsm.conf</code>. Read the guide on <a href="https://raymii.org/s/tutorials/Encrypt_and_decrypt_files_to_public_keys_via_the_OpenSSL_Command_Line.html">encrypting with OpenSSL as well</a>.</p>

<p>Create a small file with text to encrypt:</p>

<pre><code>echo &#39;Remy is awesome&#39; &gt; smallfile
</code></pre>

<p>Encrypt it with the HSM public key:</p>

<pre><code>openssl rsautl -inkey publickey.pem -pubin -encrypt -pkcs -in smallfile -out encryptedsmallfile.pkcs1
</code></pre>

<p>It&#39;s encrypted:</p>

<pre><code>cat encryptedsmallfile.pkcs1  |  base64
</code></pre>

<p>Output:</p>

<pre><code>klI3DdYbMOW+WltGmSmCiEntXyI7NT/sFmGBjgXHpRDv8xS+CnUWc4hAKPC7cJERlg5Bl0E6me/Z
8J4Q77xorFHSvoeKx0plIhIMlE429cBlMcJGj1o/wnSyaL7sk5H6JU03JNm3KB6wTt3B0vDf5U4O
Z5pL4SVLXMwZk/utCms=
</code></pre>

<p>Opposed to the small file:</p>

<pre><code>cat smallfile | base64
</code></pre>

<p>Output:</p>

<pre><code>UmVteSBpcyBhd2Vzb21lCg==
</code></pre>

<p>Now we&#39;re going to use the DKEK to get the private key from the device. Use the earlier compiled <code>sc-hsm-tool</code> to get the HEX DKEK:</p>

<pre><code>./src/tools/sc-hsm-tool --print-dkek-share ~/tmp/hsm/dkek-share-1.pbe 
</code></pre>

<p>Output:</p>

<pre><code>Using reader with a card: Nitrokey Nitrokey HSM (010000000000000000000000) 00 00
Enter password to decrypt DKEK share : 

Deciphering DKEK share, please wait...
DKEK Share HEX: 

20B3EE1CABA5ECA7ECEB6BE51F11BD9A04F5FE9A6B0A1E0A8BC13074D32CF830
</code></pre>

<p>Place this value in the <code>decrypt_keyblob_2.js</code> script:</p>

<pre><code>var dkekshare2 = new ByteString(&quot;20B3EE1CABA5ECA7ECEB6BE51F11BD9A04F5FE9A6B0A1E0A8BC13074D32CF830&quot;, HEX);
</code></pre>

<p>Also change the keyref if needed:</p>

<pre><code>var keyblob = sc.wrapKey(1);
</code></pre>

<p>Use the SmartCard Shell to run this <code>decrypt_keyblob_2.js</code> script. The output you need is listed below:</p>

<pre><code>Prime factor p        : FBC979E63BC8034B6D36008FA9482816F36C513B9905ED3CD089E74576260CB4E50F457452C88AD10646DE115AD37923D0B88F1779EA67D11D6D8F8DBFA670D7 (64)
Prime factor q        : C0361270B921E5853077AE847B2EADB5C9E0285854F6E4AC27BEBE1D18BFF9DFF6DC5D5422B7AB560D351ACDCE15DAE81DB97FBB184A228480B427E3BE93589B (64)
Modulus               : BD0C4A0F6C341365CCD24CE66C8FCDD9A896A2FB7655A83E5F1482EA13DDB0DF395C1BED2A9ED2E1C310A7610211BF4ADE0092104F910DE160B444FFAF1F68F8DE89CCFA8DA857108FAA5724738C10D120F78779DC6C53B8D3348A2C6AFD90977B208C72BDC7ACE99B5575CC4EE3D51CBFBE01C780FF8D61404408AB9E053A2D (128)
Exponent              : 010001 (3)
</code></pre>

<p>You can see that the <code>KCV</code> is the same as the <code>sc-hsm-tool</code> DKEK key check value:</p>

<pre><code>sc-hsm-tool 
Using reader with a card: Nitrokey Nitrokey HSM (010000000000000000000000) 00 00
Version              : 2.0
Config options       :
  User PIN reset with SO-PIN enabled
SO-PIN tries left    : 15
User PIN tries left  : 3
DKEK shares          : 1
DKEK key check value : 0FB85F69F6EBF256


# scsh
Values derived from DKEK shared:
--------------------------------
DKEK        : 20B3EE1CABA5ECA7ECEB6BE51F11BD9A04F5FE9A6B0A1E0A8BC13074D32CF830
KVC         : 0FB85F69F6EBF256
Kenc        : 6890320D25D318530C3AB5988E29D8DF445E5F5ACE223364F41000394614B763
Kmac        : BE9BA334E3A89E75E7E8308AE2C28DF3CCC4FDA8B805112E03AD0C3FD452E9A0
</code></pre>

<p>Read on to see how to reconstruct the private key with some python. </p>

<h3>Reconstructing the key</h3>

<p>Make sure you have <code>gmpy</code> and <code>PyCrypto</code> installed. I&#39;m using the following python code to recontruct the private key:</p>

<pre><code>#/usr/bin/python2
import gmpy
from Crypto.PublicKey import RSA
# pkcs15-tool --read-public-key
pub = RSA.importKey(&quot;&quot;&quot;-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC9DEoPbDQTZczSTOZsj83ZqJai
+3ZVqD5fFILqE92w3zlcG+0qntLhwxCnYQIRv0reAJIQT5EN4WC0RP+vH2j43onM
+o2oVxCPqlckc4wQ0SD3h3ncbFO40zSKLGr9kJd7IIxyvces6ZtVdcxO49Ucv74B
x4D/jWFARAirngU6LQIDAQAB
-----END PUBLIC KEY-----&quot;&quot;)
# Prime factor p
p = int(&quot;FBC979E63BC8034B6D36008FA9482816F36C513B9905ED3CD089E74576260CB4E50F457452C88AD10646DE115AD37923D0B88F1779EA67D11D6D8F8DBFA670D7&quot;, 16)
# Prime factor q
q = int(&quot;C0361270B921E5853077AE847B2EADB5C9E0285854F6E4AC27BEBE1D18BFF9DFF6DC5D5422B7AB560D351ACDCE15DAE81DB97FBB184A228480B427E3BE93589B&quot;, 16)
# Exponent
e = long(pub.e)
# Modulus
n = long(pub.n)
# private exponent
d = long(gmpy.invert(e,(p-1)*(q-1)))

key = RSA.construct((n,e,d))

print key.exportKey()

print key.publickey().exportKey()
</code></pre>

<p>The output from this script:</p>

<pre><code># &gt;&gt;&gt; print key.exportKey()
-----BEGIN RSA PRIVATE KEY-----
MIICXQIBAAKBgQC9DEoPbDQTZczSTOZsj83ZqJai+3ZVqD5fFILqE92w3zlcG+0q
ntLhwxCnYQIRv0reAJIQT5EN4WC0RP+vH2j43onM+o2oVxCPqlckc4wQ0SD3h3nc
bFO40zSKLGr9kJd7IIxyvces6ZtVdcxO49Ucv74Bx4D/jWFARAirngU6LQIDAQAB
AoGASAr54jy677V4w5/YpAB9UvgjR8MKioQOGM/JQAkID9JRmp9t1zMlbDGZFCAs
2LSMhGO1Rg/8WEzOPISa55LRvnRkOVPe7ps3NTGynlx028PFc7ddK2tFDgAAq3Sd
sj6+1wskDOd0jHZ/rMsl2LZJHy6TgegDZEwpz8TCLaNWNQUCQQDANhJwuSHlhTB3
roR7Lq21yeAoWFT25Kwnvr4dGL/53/bcXVQit6tWDTUazc4V2ugduX+7GEoihIC0
J+O+k1ibAkEA+8l55jvIA0ttNgCPqUgoFvNsUTuZBe080InnRXYmDLTlD0V0UsiK
0QZG3hFa03kj0LiPF3nqZ9EdbY+Nv6Zw1wJAB6efoGGfGfbt8TZADG/VdzHs/W5X
I+YDfSm5hIshyh/DQw9sdF2AM1MfVEvx8yjeqaBjl93lxe4k+gfEqChSFQJBAMv/
Xv5ErTbOI7u/FKZIygJeUwI10TNWFRG4yWIj6Ywd/AA1e5ue06mq9jvxv67a1UPE
ZFrW8i4O5VLhHi2Kwp0CQQCd6au8XXhtY64/Tei73LqqmJFXH+XLROB7Zmw6+OOY
fCz66jLobiDBbX5ubdAkLbzot9LXbAAEE1eChUjNfJQs
-----END RSA PRIVATE KEY-----
</code></pre>

<p>Place this private key in a file (<code>hsm.priv</code>).</p>

<p>Use OpenSSL to decrypt the encrypted file with the keyfile:</p>

<pre><code>openssl rsautl -decrypt -inkey hsm.priv -in encryptedsmallfile.pkcs1 
</code></pre>

<p>Output:</p>

<pre><code>Remy is awesome
</code></pre>

<p>You can also use the HSM to decrypt:</p>

<pre><code>pkcs15-crypt --decipher --key 2 --input encryptedsmallfile.pkcs1 --pkcs1 --raw 
</code></pre>

<p>Output:</p>

<pre><code>Using reader with a card: Nitrokey Nitrokey HSM (010000000000000000000000) 00 00
Enter PIN [UserPIN]: 648219
Remy is awesome
</code></pre>

<h3>Rationale</h3>

<p>As said above, having access to the unencrypted private keys defeats the entire purpose of an HSM, namely that you never have access to the private key. This decrypted key can be stolen or abused.</p>

<p>However, to decrypt the wrapped key you need access to:</p>

<ul>
<li>All the DKEK shares</li>
<li>All the DKEK passwords</li>
<li>The HSM device</li>
<li>SO pin</li>
<li>User pin</li>
</ul>

<p>In a production environment you would not use the default pins. You change those. You also don&#39;t have one DKEK share with one password, you have multiple DKEK shares where each DKEK share has multiple passwords (n-of-m scheme). These DKEK shares are stored in a secure place (keepass, printed in a bank safe, etc). Then multiple people and multiple passwords are required to initialize the HSM (or to calculate the unencrypted DKEK share).</p>

<p>This is a convinience because you might need to export the key out of the HSM when you are migrating to another HSM, from a different manufacturer. Or, you are decomissioning this HSM and the software attached to it, but want to archive the key because it might be needed later. You might even just want to use the same key in different software that does not support PKCS#11.</p>

<p>Since it requires so many steps and so much access, I don&#39;t think this is a huge risk, but a rather nice convinience.</p>

<p>I do am of the opinion that HSM&#39;s should not offer this option (getting access to the private key). But then you would also not be able to backup and transfer the wrapped keys, since that can be reverse engineered. I&#39;ve seen multiple big-name HSM&#39;s where their support was able to decrypt the key and transfer it to another HSM model, but since I&#39;ve signed an NDA I cannot tell which ones that were. You will have to take my word for it.</p>

<p>That does pose the question, how will you make sure you have a backup? Since these devices can fail, just as any device, you would want to make sure you have a backup, since your business probably depends on the availability of a HSM. I find it a hard problem and I don&#39;t know an actual solution to both provide backup possibilities and disallow access of the private key.</p>

<p>Some HSM manufacturers have the option to stream the transportkey over the network to another device, or to use a smartcard to transfer the key. I do suspect that they have a private key somewhere that protects the encrypted (wrapped) backup key and that it would be hard to reverse engineer their process. But, a nation-state level actor would surely have the resources to reverse engineer the backup process, just as we did here.</p>

<h3>sc-hsm-tool.c code</h3>

<p>The full <code>sc-hsm-tool.c</code> file with the DKEK print option, is downloadable from <a href="https://raymii.org/s/inc/downloads/sc-hsm-tool.c.txt">here</a>.</p>
</div><hr>Tags: <a href="../tags/cryptoki.html" class="link">cryptoki, </a><a href="../tags/dkek.html" class="link">dkek, </a><a href="../tags/hsm.html" class="link">hsm, </a><a href="../tags/nitrokey.html" class="link">nitrokey, </a><a href="../tags/openssl.html" class="link">openssl, </a><a href="../tags/pkcs11.html" class="link">pkcs11, </a><a href="../tags/safenet.html" class="link">safenet, </a><a href="../tags/sc-hsm.html" class="link">sc-hsm, </a><a href="../tags/smartcard.html" class="link">smartcard, </a><a href="../tags/smartcard-hsm.html" class="link">smartcard-hsm, </a><div class="footer">
                <hr>
                <p>Generated by <a href="/s/software/ingsoc.html">ingsoc</a> | 
                <a href="/s/software/Sparkling_Network.html">Cluster Status</a> | 
                <a href="/s/static/About.html">About</a><br />
                </div>
            </div>
        </div>
    </div>  
    </div>
    </div>
     
    <!-- Piwik --> 
    <script type="text/javascript">
    var pkBaseURL = (("https:" == document.location.protocol) ? "https://hosted-oswa.org/piwik/" : "http://hosted-oswa.org/piwik/");
    document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
    </script><script type="text/javascript">
    try {
    var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 1);
    piwikTracker.trackPageView();
    piwikTracker.enableLinkTracking();
    } catch( err ) {}
    </script><noscript><p><img src="http://hosted-oswa.org/piwik/piwik.php?idsite=1" style="border:0" alt="" /></p></noscript>
    <!-- End Piwik Tracking Code -->
    </body>
    </html>
    