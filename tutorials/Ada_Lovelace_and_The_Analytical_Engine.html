<!DOCTYPE html><html lang="en"><head><title>Ada Lovelace and The Analytical Engine - Raymii.org</title><link href="/s/inc/css/custom-first.css" rel="stylesheet"/><link href="/s/inc/css/light.css" rel="stylesheet"/><link href="/s/inc/css/custom.css" rel="stylesheet" title="custom"/><meta content="text/html;charset=utf-8" http-equiv="Content-Type"/><link href="inc/img/icons/iphone.png" rel="apple-touch-icon"/><link href="inc/img/icons/ipad.png" rel="apple-touch-icon" sizes="76x76"/><link href="inc/img/icons/iphone-retina.png" rel="apple-touch-icon" sizes="120x120"/><link href="inc/img/icons/ipad-retina.png" rel="apple-touch-icon" sizes="152x152"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><link href="/s/inc/opensearch.xml" rel="search" type="application/opensearchdescription+xml"/><link href="https://raymii.org/s/feed.xml" rel="alternate" title="RSS Feed for Raymii.org" type="application/rss+xml"/></head><body><a id="top-of-page"></a><div class="container-fluid "><div class="row"><div class="col-md-12"><div class="col-md-3 col-sm-3 max-200"><div class="well well-none"><h3 class="headheader"><a href="https://raymii.org/s/">Raymii.org<img alt="IEC Resistor logo" src="/s/inc/img/resistor-50.png"/></a></h3><h6 class="headheader">Quis custodiet ipsos custodes?</h6><h6><a href="https://raymii.org/s/feed.xml">RSS Feed</a></h6></div><form action="https://encrypted.google.com/search" role="search"><div class="form-group"><input name="as_sitesearch" type="hidden" value="raymii.org"/><input name="as_qdr" type="hidden" value="all"/><input class="form-control" name="as_q" placeholder="Search" type="text"/></div></form><div class="menu"><ul class="nav nav-pills nav-stacked"><li><a class="special-menu" href="/s/index.html">Home</a></li><li class="bottom-spacing"><a class="special-menu" href="/s/everything.html">All Pages</a></li><li class="hideifsmall"><a class="link" href="/s/tags/bash.html">Bash</a></li><li class="hideifsmall"><a class="link" href="/s/tags/monitoring.html">Monitoring</a></li><li class="hideifsmall"><a class="link" href="/s/tags/ssl.html">SSL</a></li><li class="hideifsmall"><a class="link" href="/s/tags/debian.html">Debian</a></li><li class="hideifsmall"><a class="link" href="/s/tags/python.html">Python</a></li><li class="hideifsmall"><a class="link" href="/s/tags/vpn.html">VPN</a></li><li class="hideifsmall"><a class="link" href="/s/tags/ubuntu.html">Ubuntu</a></li><li class="hideifsmall"><a class="link" href="/s/tags/nginx.html">nginx</a></li><li class="hideifsmall"><a class="link" href="/s/tags/openstack.html">Openstack</a></li><li class="hideifsmall"><a class="link" href="/s/tags/ansible.html">Ansible</a></li></ul><a href="http://clients.inceptionhosting.com/aff.php?aff=083">Inception Hosting Affiliate Link</a><br/> <a href="https://www.digitalocean.com/?refcode=7435ae6b8212">Digital Ocean Affiliate Link, $10 free credit.</a><br/><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" data-ad-client="ca-pub-7993642564731324" data-ad-slot="9322003332" style="display:inline-block;width:200px;height:200px"></ins><script>
                (adsbygoogle = window.adsbygoogle || []).push({});
                </script></div></div><div class="col-md-8 col-sm-8"><div class="inner"><h2 class="headheader">Ada Lovelace and The Analytical Engine</h2><ul class="breadcrumb"><li><a class="link" href="../index.html">Home</a></li><li><a class="link" href="../tutorials/index.html">Tutorials</a></li><li><a class="link" href="Ada_Lovelace_and_The_Analytical_Engine.html">Ada Lovelace and The Analytical Engine</a></li></ul><p><small>09-03-2015</small> | <small>Juliet Kemp</small></p><div class="ad"><script async="" src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" data-ad-client="ca-pub-7993642564731324" data-ad-slot="6172324376" style="display:inline-block;width:728px;height:90px"></ins><script>
                            (adsbygoogle = window.adsbygoogle || []).push({});
                            </script></div><br/><p>This article was originaly published in <a href="http://www.linuxvoice.com/download-linux-voice-issue-1-with-audio/">Linux Voice, issue 1, April 2014</a>. This issue is now available under a <a href="https://creativecommons.org/licenses/by-sa/3.0/">Creative Commons BY-SA license</a>. In a nutshell: you can modify and share all content from the magazine (apart from adverts), even for commercial purposes, providing you credit Linux Voice as the original source, and retain the same license.</p><p>This remix is converted manually to Markdown and HTML for ease of archiving and copy-pasting.</p><p>If you like this, please subscribe to Linux Voice. It is an awesome magazine with an awesome team of people. <a href="http://shop.linuxvoice.com/">Click here to subscribe</a> from just GBP 38 and get future issues straight to your door or inbox! (DRM Free PDF's and more available).</p><p>If you like this website and want to support it AND get $10 Digital Ocean credit (2 months free), use this link to order: <a href="https://www.digitalocean.com/?refcode=7435ae6b8212">https://www.digitalocean.com/?refcode=7435ae6b8212</a> (referral link).</p><p>Other converted Linux Voice articles <a href="https://raymii.org/s/tags/linux-voice.html">can be found here</a>.</p><hr/><p>Use the Linux Voice time machine to take a trip to Victorian England, and visit one of the pioneers of the computer age.</p><h3>Ada Lovelace and The Analytical Engine</h3><p>Back in the 19th century, if you wanted to do complicated mathematical calculations you had to do them by hand. To speed things up, you could buy printed tables of specific calculations such as logarithms but as these too were calculated by hand, they were full of errors.</p><p>Enter Charles Babbage, mathematician, philosopher, engineer and inventor, who in the early 1820s designed a Difference Engine to do these calculations automatically. The Difference Engine could only add up, so it wasn't a general-purpose 'computer'. It also never existed in Babbage's time, although part of a prototype was constructed. Babbage fell out with his engineer and ran out of funding, so construction stalled around 1833 and was finally abandoned in 1842.</p><p>Meanwhile, in 1834 Babbage began to design a more complex machine called the Analytical Engine. This would be able to add, subtract, multiply, and divide, and it is the Analytical Engine that can be considered as the first general-purpose computer.</p><p>Or could, if it had ever existed: Babbage built a few pieces of prototype, and carried on refining the design until his death in 1871, but never found funding for the full thing.</p><p>But despite its lack of concrete existence, other mathematicians were interested in it, including Louis Menebrae, and Ada Lovelace, who was already corresponding with Babbage.</p><h3>Augusta Ada King, Countess of Lovelace</h3><p><img alt="ada1" src="https://raymii.org/s/inc/img/linuxvoice/1/ada1.png"/></p><blockquote><p>Ada Lovelace was the daughter of Lady Annabella Byron, who was deeply interested in mathematics, and Lord Byron. What would she have thought of the person who's produced Engine code that draws a cat?</p></blockquote><p>Ada Lovelace had had extensive mathematical training as a child. She first met Babbage in 1833, aged 17, and corresponded with him on mathematics and logic. Around 1841 Luigi Menabrae wrote a 'Sketch' of the Analytical Engine, describing its operation and how one might use it for a calculation. Lovelace was asked to translate it into English; not only did she do that, but at Babbage's request she added her own extensive Notes, which went much further than Menabrae had.</p><p>Lovelace probably saw more in the Analytical Engine than Babbage himself had. She suggests, for example that it might act upon 'other things beside number', and that it might be possible to compose music by representing it in terms of the Engine's notation and operations. This jump from a mathematical engine to one that could act on symbols of any sort was visionary and well ahead of her time.</p><p>The Notes, importantly, contained the first computer algorithm a series of steps of operations to solve a particular (in this case mathematical) problem. This is what any computer program does, and is what makes Ada the first computer programmer, even if she was never able to run her program on a real machine.</p><h3>Installing the Analytical Engine</h3><p>Although no physical Analytical Engine exists (the Science Museum in London has a working replica of the Difference engine), Fourmilab Switzerland have an emulator available. It runs on Java, so all you need to run it is a JDK. Download the emulator object code from <a href="http://www.fourmilab.ch/babbage/contents.html">www.fourmilab.ch/babbage/contents.html</a>, unzip it, and type <code>java aes card.ae</code> from that directory to run the card file <code>card.ae</code>.</p><p>The emulator is the best guess, based on Babbage's drawings and papers over the years, of how the Engine would have worked. You can also use it as an applet, for which you'll have to download and compile the source code, but we couldn't easily get this to compile. The applet gives a more visual interface.</p><h3>Basic operations and a first program</h3><p>The Analytical Engine consisted of the Mill (where processing was done) and the Store (where numbers and intermediate results were held). The Store had 1000 registers (a far bigger memory than the first 'real' computers had), and the Mill could take in two numbers, conduct an operation on them, and output a single number.</p><p>The Engine would also run a printing device for output, to avoid errors in transcription. It would be operated by punch cards, as were used in Jacquard looms to weave complex patterns.</p><p>To use the emulator, then, we type in punch-card-type instructions to be run one at a time. For ease, you can put any number of cards into a single text file.</p><p>There are three types of punch cards:</p><ul><li>Operation Cards Tell the Mill to add/subtract/multiply/divide, and can also move the chain of cards forwards or backwards (like a jump or loop instruction).</li><li>Number Cards Supply numbers to the Store as necessary.</li><li>Variable Cards Transfer values between the Mill and the Store.</li></ul><p>For engineering reasons Babbage intended these to have three separate hoppers, but in the emulator they go in a single stream. (This is also how Menabrea and Lovelace expressed their example programs.)</p><p>The emulator 'cards' also allow some flexibility in format. Numbers aren't right-justified and there's no need for leading zeros, as there would be in a real punch card.</p><p>A number card looks like this:</p><pre><code>N001 3
</code></pre><p>This sets column 1 in the Store (which has 0-999 columns) to the value 3.</p><p>The Mill has two <code>Ingress Axes</code> and an <code>Egress Axis</code> (plus two auxiliary axes for division, which we'll look at shortly). Once an operation is selected, the Mill will keep doing that until another is selected.</p><p>The Operations cards are:</p><ul><li>+</li><li>-</li><li>x or *</li><li>/ or the divison sign</li></ul><p>which all do what you'd expect.</p><p>Finally, the Variable Cards transfer things in and out of the Mill:</p><ul><li><code>L</code>: Transfer from Store to Mill Ingress Axis, leaving Store column intact.</li><li><code>Z</code>: Transfer from Store to Mill Ingress Axis, zeroing Store column.</li><li><code>S</code>: Transfer from Mill Egress Axis to Store column.</li></ul><p>The letter is followed by a number specifying the Store column.</p><p>A program on the Analytical Engine consists of a chain of cards; each text line in an emulator file is a single card. You submit a card chain to the Attendant, who will check it for errors and 'requests for actions' (such as inserting manually generated loops and subroutines). The chain of cards is then mounted on the Engine and processed.</p><p>Let's give it a go! Since The Analytical Engine doesn't lend itself to <code>Hello World</code>, we'll add 2 and 2.</p><p>Save this as <code>card1.ae</code>:</p><pre><code>N000 2
N001 2
+
L000
L001
S002
P
</code></pre><p>This code puts 2 in column 0 of the Store, 2 in column 1 of the Store, sets the operation to add, transfers column 1 and then column 2 to the Ingress Axes (whereupon the operation will be applied), then the result back to the Store in column 2.</p><p>P prints the result of the last operation to standard output. Run it with <code>java aes card1.ae</code> to see what happens.</p><p><img alt="ada2" height="480" src="https://raymii.org/s/inc/img/linuxvoice/1/ada2.png" width="640"/></p><blockquote><p>The Analytical Engine emulator running a test card (in the Vim window), which subtracts 38888 from 0.</p></blockquote><p>In fact, you could miss out the second line, and transfer the value from Store column 0 twice, and it will automatically be transferred into both Ingress Axes. So this will work fine:</p><pre><code>N000 2
+
. About to put values into Mill
L000
L000
S001
P
</code></pre><p>Replacing the first <code>L000</code> with <code>Z000</code> won't work, as this zeros the Store column after transfer.</p><p>This card also includes a comment line. Comments begin with a space or a dot in column 1 of the card.</p><p>To do more operations, you need to replace both values on the Ingress Axes - they are discarded after their use in a computation. Each time two arguments go in, the current calcuation is applied.</p><h3>Menabrae and simultaneous equations</h3><p>Menabrae in his Sketch described an algorithm to solve a pair of simultaneous equations. He divided the process of solving the equations into a series of individual operations, and tabulated them as Analytical Engine operations.</p><p>This is handily arranged so that all the multiplications happen, then the subtractions, then the divisions, minimising the number of Operations cards.</p><p>Let's translate this into Analytical Engine code. See the LV website for the whole thing; I'll look at the structure and a couple of operations here.</p><p>Here are our sample equations:</p><pre><code>2x + y = 7

3x - y = 8
</code></pre><p>First, we put all the numbers (2, 1, 7; 3, -1, 8) into the Store. Then, following Menabrae's calculations, cards 1-6 do all the multiplying and store the results. Cards 7-9 are subtractions.</p><p>Then cards 10 and 11 generate and print the results. (I've described each operation as a 'card', as Lovelace does, although in the terms of the emulator, each line is a card.)</p><p>Card 10 - gives x value</p><pre><code>/
L013
L012
S015'
P
</code></pre><p>Card 11 - gives y value</p><pre><code>L014
L012
S016'
P
</code></pre><p>If you're debugging, it's useful to print at every step.</p><p>Division is a little more complicated than other operations. The format is roughly the same, but dividing uses the Primed Egress Output. Specifically, the remainder from the operation goes on the regular Egress Output, and the quotient (which is usually what you want) goes on the Primed Egress Output.</p><p>You get at this by using an apostrophe. (Very large numbers can also use the Primed Ingress Axis.) Run this with <code>java aes simeqcard.ae</code> and you should get two numbers output: 3 (the x value) and 1 (the y value).</p><p>The dividing shown works fine if you have integer results or only need integer precision. But what if you want a greater precision?</p><p>The Analytical Engine uses fixed point arithmetic: like a slide rule, it calculates only in whole numbers, and it is the programmer's responsibility to keep track of decimal places.</p><p>So there is a "step up" and a "step down" operation, which shifts the decimal point either to the right (stepping up x times, or multiplying by 10x) or to the left (stepping down, or dividing by 10x).</p><p>We just need to change the last two cards:</p><p>Card 10 - gives x value</p><pre><code>/
L013
L012
S015'
P
</code></pre><p>Card 11 - gives y value</p><pre><code>L014
L012
S016'
P
</code></pre><p>We must put the decimal point back in to the output ourselves, by manually dividing by 100,000 (105).</p><h3>Ada and the Bernoulli numbers</h3><p>The most interesting part of Ada Lovelace's notes on the Menabrae paper describes how to calculate the Bernoulli numbers (a set of numbers of deep interest to theoretical mathematicians) using the Engine.</p><p>Her diagram of the process is too complicated to reproduce here, but can be seen (with the rest of the Notes) at <a href="www.fourmilab.ch/babbage/sketch.html">www.fourmilab.ch/babbage/sketch.html</a>.</p><p>It can, however, be translated into code for the Analytical Engine emulator.Download the full code from the LV website; here we'll look at the structure and ideas.</p><p><img alt="ada3" height="480" src="https://raymii.org/s/inc/img/linuxvoice/1/ada3.png" width="640"/></p><blockquote><p>Ada Lovelace's equation for deriving the Bernoulli numbers.</p></blockquote><p>The non-zero Bernoulli numbers are usually referred to by modern mathematicians as B2, B4, B6, etc. However, Ada Lovelace refers to them as B1, B3, etc. I will refer to them here by the modern numbers (so subtract one if you're comparing with the Notes directly).</p><p>There are many ways to derive them, but the equation that Lovelace uses is shown, left. Note that the very last Bernoulli number has no accompanying A-equation. What we're trying to calculate.</p><p>The important point is that from A2 onwards, each following A-value takes the preceding one and multiplies by another two terms. This makes it possible to construct an iterative process to calculate each succeeding term.</p><p>Onwards then to the code!</p><p>Following Lovelace's diagram, we will put in an already-calculated version of B2, B4, and B6, and will calculate B8, so <code>n</code> is 4.</p><p>As Lovelace was keen to point out, in a 'real' calcuation the Engine itself would have already calculated these values on a previous round of the program, so they're stored in a later register.</p><p>The first section of the code, then, sets up our numbers. Register 3 holds our <code>n</code>, and registers 21-23 the first 3 Bernoulli numbers, multiplied by 10,000 (to allow for later dividing, as discussed above).</p><p>Cards 1-6 calculate -1/2 x (2n - 1)/(2n + 1). The last three are the most interesting:</p><p>Card 4: (2n - 1) / (2n + 1)</p><pre><code>/
L004
&lt;5
L005
S011'
</code></pre><p>Card 5: 1/2 * (2n - 1) / (2n + 1) Y</p><pre><code>L011
L002
S011'
</code></pre><p>Card 6: -1/2 * (2n - 1) / (2n + 1) Y</p><pre><code>-
L013
L011
S013
</code></pre><p>In Card 4, we step the first value up 5 places before dividing, to avoid a rounding error.</p><p>In Card 5, we take the value stored in the previous step and overwrite it, since it won't be needed again.</p><p>In Card 6, we take advantage of the fact that any unused register reads 0, to get a minus number by subtracting register 11 from zero. Effectively this switches the sign of the value in step 5, but we store this result in register 13.</p><p>7 subtracts one from <code>n</code>. This isn't used in the code as it stands, but it is a notional counter to keep track of whether we need to do another round of calcuation.</p><p>If we were calculating B2 (so n = 1), then card 7 would give the result 0, and we would be done. Otherwise, it should add 1 to n and go round again.</p><p>Lovelace presupposed that the Analytical Engine would have a way of detecting a specific result and acting accordingly. (The emulator provides an alternation card to do exactly this.)</p><p>Steps 8-10 produce (2n / 2) * B2 (the latter being stored already).</p><p>Card 11 adds the value from the first stage (A0), and card 12 again checks whether we're finished yet.</p><p>The intriguing part is the next stage, cards 13-23. This is the section that could be repeated almost exactly for any stage of the process, however many numbers you wanted to calculate. What you need to calculate each time is:</p><pre><code>2n . (2n - 1) . (2n - 2) ... / 2 . 3 . 4 ...
</code></pre><p>This is equivalent to</p><pre><code>2n / 2 . (2n - 1)/3 . (2n - 2)/4 ...
</code></pre><p>The first time we go through the loop, when calculating A3, we can forget about 2n / 2 as we already calculated that on card 9, and saved it in location 011.</p><p>So we work out 2n - 1 (card 13) and 2 + 1 (card 14), divide them and save the result (card 15; note again that we step up 5 decimal places), and then multiply it with A0 and save this new value in location 11.</p><p>We then repeat the exercise, with cards 17-20, with (2n - 2) / 4, multiply it with the previous result, and overwrite location 011 again. So, once again, our A-value is stored in location 11.</p><p>In card 21, we multiply with our pre-saved value for B4, then add the whole sequence up and save it in location 13. Card 23 once again checks for 0. At this point, all we need to do is to run cards 13-23 all over again.</p><p>Because we saved 2n - 2 as our 'new' 2n, in location 6, applying cards 13-16 produces the result (2n - 4)/ 5, just as we want.</p><p>And the same again for cards 17-20, with (2n - 5) / 6 multiplied in this time. The only change is that in card 21, we have to grab B6 from its location rather than B4.</p><p>Then we add it all together again. In the code, these second-time-around cards are labelled 13B-23B.</p><p>Card 13: 2n - 1 Y</p><pre><code>L006
L001
S006
</code></pre><p>Card 14: 2 + 1 Y</p><pre><code>+
L002
L001
S007
</code></pre><p>Card 15: (2n - 1) / (2 + 1)</p><pre><code>/
L006
&lt;5
L007
S008'
</code></pre><p>Card 16: (2n / 2) * ((2n - 1) / 3) Y</p><pre><code>*
L011
L008
S011
</code></pre><p>Card 17: 2n - 2 Y</p><pre><code>-
L006
L001
S006
</code></pre><p>Card 18: 3 + 1 Y</p><pre><code>+
L001
L007
S007
</code></pre><p>Card 19: (2n - 2) / 4 Y</p><pre><code>/
L006
&lt;5
L007
S009'
</code></pre><p>Card 20: (2n / 2) * (2n - 1)/3 * (2n - 2)/4 Y</p><pre><code>*
L009
L011
&gt;5
S011
</code></pre><p>Card 21: B(4) * [Card 20]</p><pre><code>L022
L011
&gt;5
S012
</code></pre><p>Card 22: A0 + B2A2 + B4A4 Y</p><pre><code>+
L012
L013
S013
</code></pre><p>There's only one new thing to notice, which is that in cards 20 and 21 we have to step our result from the multiplication back down by five decimal places, as we're multiplying two stepped-up values together.</p><p>The final step is 24, in which we add our saved value from step 23 to a zero register, to give our calculated Bernoulli number. In actual fact, we should be subtracting this from zero to get the sign of the number correct, but Lovelace explicitly chose to ignore this. Once the result is output, remember that you'll also need to manually put in the decimal point, five places to the left. So our result is -0.03341.</p><p>This is not far off the 'official' -0.033333333. Try altering the accuracy of our calculations (remember also to alter the accuracy of the stored Bernoulli numbers) to improve the accuracy of the result.</p><p>The Analytical Engine emulator also supports looping code, using conditional and unconditional cycle (backing) cards, and straightforward backing/advancing cards; and an if/then clause with the alternation card.</p><p>See the website for more details, and have a go at rewriting the provided code to loop over one Bernoulli number at a time, up to a given n, generating the result and storing it for the next loop around.</p><p>Remember that you'll need to calculate A0, A2, and B2 separately, as here (cards 1-12), before you can get into the real 'loop' part. As the emulator is Turing-complete you can also, as Lovelace suggested, produce anything you can translate into Engine-operations; or, as we now think of it, assembly language. In theory you could even write a compiler in Engine code</p><blockquote><p>Juliet Kemp is a scary polymath, and is the author of O'Reilly's Linux System Administration Recipes</p></blockquote><hr/>Tags: <a class="link" href="../tags/ada.html">ada,</a><a class="link" href="../tags/ada-lovelace.html">ada-lovelace,</a><a class="link" href="../tags/analytical-engine.html">analytical-engine,</a><a class="link" href="../tags/bernoulli.html">bernoulli,</a><a class="link" href="../tags/difference-engine.html">difference-engine,</a><a class="link" href="../tags/linux-voice.html">linux-voice,</a><a class="link" href="../tags/linux-voice-issue-1-2014.html">linux-voice-issue-1-2014,</a><a class="link" href="../tags/math.html">math,</a><div class="footer"><hr/><p>Generated by <a href="/s/software/ingsoc.html">ingsoc</a> | <a href="/s/software/Sparkling_Network.html">Cluster Status</a> | <a href="/s/static/About.html">About</a><br/></p></div></div></div></div></div></div><script type="text/javascript">
    var pkBaseURL = (("https:" == document.location.protocol) ? "https://hosted-oswa.org/piwik/" : "http://hosted-oswa.org/piwik/");
    document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
    </script><script type="text/javascript">
    try {
    var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 1);
    piwikTracker.trackPageView();
    piwikTracker.enableLinkTracking();
    } catch( err ) {}
    </script><noscript>&lt;p&gt;&lt;img src="http://hosted-oswa.org/piwik/piwik.php?idsite=1" style="border:0" alt="" /&gt;&lt;/p&gt;</noscript></body></html>